---
author: zjmantou
title: 07虚拟机类加载机制
time: 2023-11-19 周日
tags:
  - Java
  - Java虚拟机
  - 笔记
---
# 生命周期

![类加载周期.jpeg](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202311191957594.jpeg)

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。

## 加载（Loading）

**通过ClassLoader获取类的二进制流，转化为方法区的运行时数据结构，生成Class对象，作为方法区这个类的访问入口。**

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

二进制流获取路径：
1. ZIP包
2. 网络获取
3. 运行时计算生成，这种场景使用得最多的就是**动态代理技术**，在java.lang.reflect.
4. Proxy中，就是用了ProxyGenerator.generateProxyClass来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。
5. 其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类。
6. 数据库中读取。


## 连接（Linking）

### 验证（Verification）

**确保Class文件的字节流包含的信息复合当前虚拟机的要求，不会危害虚拟机自身安全。** 

不符合的话就会抛出 **VerifyError错误**  

#### 1.文件格式验证

验证字节流是否符合Class文件格式规范。 

- 是否以魔数0xCAFEBABE开头。
- 主、次版本号是否在当前虚拟机处理范围之内。
- 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
- CONSTANT_Utf8_info型的常量中是否有不符合UTF8编码的数据。
- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。

#### 2.元数据验证

堆字节码描述的信息进行语义分析，以确保符合Java语言规范要求。 

- 这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。
- 这个类的父类是否继承了不允许被继承的类（被final修饰的类）。
- 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。
- 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。

#### 3.字节码验证

通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 

保证被校验类的方法在运行时不会做出危害虚拟机安全的事件：
- 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中。
- 保证跳转指令不会跳转到方法体以外的字节码指令上。
- 保证方法体中的类型转换是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。

#### 4.符号引用验证

在解析阶段发生，对类自身以外的信息进行匹配行校验：
- 符号引用中通过字符串描述的全限定名是否能找到对应的类。
- 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。
- 符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问。

### 准备（Preparation）

正式为类变量（static修饰变量）分配内存并设置类变量初始值（赋0）的阶段。

当类的字段属性表中存在ConstantValue时属性，在这个阶段就会初始化为这个value值，比如：

```Java
public static final int value = 123;​​
```


### 解析（Resolution）

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 

解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 

>分别对应于常量池的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info

直接引用：比如时目标指针、相对偏移量或者能间接定位到目标的句柄。

虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

## 初始化（Initialization）

执行类构造器`<clinit>()`方法的过程. static语句块。

### 什么情况下必须立即初始化？
1. new、getstatic、putstatic或invokestatic四条字节码指令；
2. reflect包的反射调用；
3. 初始化一个类的时候，如果父类没有初始化，则需要先出发其父类初始化；
4. 虚拟机启动时的主类（main）；
5. MethodHandle实例解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。



## 使用（using）

## 卸载（Unloading）

# 类加载器ClassLoader

比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。

## 双亲委派模型

![双亲委派模型.jpeg](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202311192044137.jpeg)

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

保证类的优先级层次关系，比如核心类Object无论哪个类加载起加载这个类，最终都是委派给最顶层的启动类加载器加载，保证在各种类加载器中都是同一个类。

### 启动类加载器（Bootstrap ClassLoader）

负责存放JDK核心API类库

### 扩展类加载器（Extension ClassLoader）

它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。

### 应用程序类加载器（Application ClassLoader）

负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。


