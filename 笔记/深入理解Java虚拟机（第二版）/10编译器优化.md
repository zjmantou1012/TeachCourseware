---
author: zjmantou
title: 10编译器优化
time: 2023-12-11 周一
tags:
  - Java
  - Java虚拟机
  - 笔记
---
# Javac编译过程


![album_temp_1702281702.PNG](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202312111602214.PNG)

如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round。 

## final字段对局部变量的影响 #final

```Java
// 方法一带有final修饰￼
public void foo(final int arg) {
￼       final int var = 0;
￼       // do something
￼ }
​​// 方法二没有final修饰
￼ public void foo(int arg) {
￼       int var = 0;
￼       // do something
￼ }​
```

对运行期没有影响。  

因为局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，甚至可能连名称都不会保留下来（取决于编译时的选项），自然在Class文件中不可能知道一个局部变量是不是声明为final了。所以final仅仅在编译期间保障。 

# 泛型

## 泛型擦除

只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList`<int>`与ArrayList`<String>`就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。

擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。 

