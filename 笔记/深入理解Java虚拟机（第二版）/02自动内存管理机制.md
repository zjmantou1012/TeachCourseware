---
author: zjmantou
title: 02自动内存管理机制
time: 2023-10-31 周二
tags:
  - Java
  - 笔记
  - 内存管理
---
# 运行时数据区域

![Java虚拟机运行时数据区](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202310310207895.jpg)

## 程序计数器

Program Counter Register 

线程私有 

是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 

每条线程都有一个独立的程序计数器，为了县城切换后能恢复到正确的执行位置。 

- 如果线程在执行Java方法：计数器记录的是正在执行的虚拟机字节码指令的地址；
- 如果线程在执行Native方法：计数器为Undefined。


**多线程是通过线程轮流切换分配处理器执行时间的方式来实现的**

三种情况：
- 返回指令所在行数
- 返回执行的虚拟机字节码指令的地址
- 返回空

## Java虚拟机栈

Java Virtual Machine Stacks

线程私有 

描述Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧； 
栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 

局部变量表存放的是基本数据类型、对象饮用和returnAddress类型； 
retrunAddress类型记录了一条字节码指令的地址。 

### StackOverflowError

线程请求的栈深度大于虚拟机所允许的深度  

### OutOfMemoryError

当虚拟机栈动态扩展的时候，无法申请到足够的内存。

## 本地方法栈

Native Method Stack

虚拟机使用到的Native方法服务。

## Java堆

Java Heap

被所有线程共享的一块区域 

存储所有对象实例 

GC 

分代收集算法：
- 新生代
	- Eden空间
	- From Survivor空间
	- To Survivor空间
- 老年代

可以通过（-Xmx和-Xms）动态扩展

## 方法区

Method Area

各个线程共享 

用于存储被虚拟机加载的类信息、常量、静态变量、即使编译器编译后的代码等数据。 

### 运行时常量池

Runtime Constant Pool

方法区的一部分  

用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 

相比Class文件，比较宽松规范，另外也具备动态性，运行期间也可能将新的常量放入池中，比如String的intern()方法。

## 会出发OutMemoryError的区域

虚拟机栈、本地方法栈、堆、方法区、常量池

## 直接内存（DirectByteBuffer）

Java NIO（New I/O）库中一个重要的组件 ，提供了一种直接访问堆外内存的方式。这种方式可以避免在Java堆和堆外内存之间频繁拷贝数据，提高了I/O的效率。

通常用于处理大量数据的场景，如网络传输、文件读写等。可以减少内存的占用，提高程序性能。 

这个也会收到本机总内存大小及处理器寻址空间的限制，也会导致OOM。 

#### NIO库还有哪些？



# 对象的创建

1. 检查类是否已经被加载、解析、初始化过；
3. 如果没有，为新生对象分配内存；
4. 将分配到的内存初始化为0值；
5. 设置对象头；
6. init初始化；

## 分配内存的方法

- 指针碰撞：将指针向空闲空间那边挪动一段与对象大小相等的距离，一般是压缩算法收集器使用的方法；
- 空闲列表：维护一个列表，记录哪些内存块是可用的，在分配的时候从列表上找到一块足够大的；标记清除法的收集器使用这种方法；

## 分配内存线程安全问题

### CAS+失败重试

### 本地线程分配缓冲

TLAB：Thread Local Allocation Buffer；

每个线程在Java堆中预先分配一小块内存。

## 对象布局

- 对象头：
	- 对象自身运行时数据：HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等；
	- 类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
- 实例数据
- 对齐填充：系统要求对象起始地址必须是8的倍数，当数据不是8的倍数时，通过这个填充对齐。

