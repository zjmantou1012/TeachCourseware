---
author: zjmantou
title: 03垃圾收集器与内存分配策略
time: 2023-11-13 周一
tags:
  - Java
  - Java虚拟机
  - 笔记
  - 垃圾收集器
---
导致Full GC的根本原因是大量的大对象存货周期很长

# 判断对象是否存活

- 引用计数算法：互相引用的对象，引用计数不为0，无法通知GC收集器回收它们
- 可达性分析算法：当一个对象到GC Roots没有任何引用链相连，证明此对象不可用

## 可作为GC Roots的对象

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI引用的对象；

## 真正宣告一个对象死亡

至少经历两次标记过程：
- 第一次标记：可达性分析后没有与GC Roots相连接的引用链；
- 对象是否有必要执行finalize（）方法：没有覆盖finalize()方法或此方法已经被虚拟机调用过，则没有必要执行。

因此要宣告一个对象正真死亡，则是第一次标记后看finalize()方法是否重写过；

# 垃圾收集算法

- 标记-清除算法
- 复制算法
- 标记-整理算法
- 分代收集算法

# HopSpot算法实现

## 枚举根节点

主要存在于全局性引用（例如常量或静态类属性）与执行上下文（例如栈帧中的本地变量表）中。

通过OopMap在特定位置记录哪些地方存放着对象引用。  

OopMap：在特定位置标记记录哪些地方存放着对象引用，以达到枚举根节点作用

## 安全点

在即将进入长时间执行指令前（比如循环跳转，异常跳转）记录一个安全点。  

## 如何让gc发生时所有线程都跑到最近的安全点上？

### 抢先式中断

gc发生时中断所有线程，如果有线程不在安全点上，就恢复线程，让它跑到安全点上

### 主动式中断

gc需要中断时，设置一个标志，各个线程执行时主动轮询这个标志，发现中断时就自己中断挂起

轮询标志的地方和安全点是重合的，还有再加上创建对象需要分配内存的地方

## 安全区域（safe region）

在这个区域中任意地方开始gc都是安全的  

为了解决线程在不执行的时候的gc  

当线程sleep或者blocked时候，这个时候出去安全区域，jvm发起gc时候，就不用管这个状态的线程，在线程要离开安全区域时，要先检查系统是否已经完成根节点枚举或整个gc过，完成了继续执行，否则等待直到可以离开安全区域的信号为止。 

# 垃圾收集器

![HotSpot虚拟机的垃圾收集器.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202311122303940.png)


## 新生代收集器

### Serial收集器

单线程工作，主要用在Client模式下单新生代收集器。 

忧点：
简单高效。

缺点：
内存很大时，停顿的时间比较多。 

### ParNew收集器 

Serial收集器的多线程版本，Server模式下首选的新生代收集器。 

### Parallel Scavenge收集器

新生代收集器，使用复制算法，并行的多线程收集器；

关注的目标是达到一个可控制的吞吐量（Throughput）。 

#### 吞吐量

CPu用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，吞吐量就是99%。 

## 老年代收集器

### Serial Old收集器

Serial收集器的老年代版本，单线程，使用“标记-整理”算法，主要用在Client模式下，在Server模式下主要用于CMS收集器的后备预案。 

### Parallel Old收集器 

Parallel Scavenge手机神器的老年代版本，多线程，“标记-整理”算法。JDK 1.6才开始提供。 

### CMS收集器

Concurrent Mark Sweep，一种以获取最短回收停顿时间为目标的收集器。 

四个步骤：
- 初始标记：（CMS initial Mark），仅仅标记一下GC Roots能直接关联到的对象，速度很快；
- 并发标记：（CMS concurrent Mark），进行GC Roots Tracing的过程；
- 重新标记：（CMS remark），为了修正并发标记期间因用户程序继续云错而导致标记产生变动的那一部分对象的标记记录；
- 并发清除：（CMS concurrent sweep）

初始标记和重新标记仍然需要“Stop The World”。

忧点：并发收集、低停顿。 

缺点：
- 对CPU资源非常敏感
- 无法处理浮动垃圾
- 标记-清除算法，会产生大量的空间碎片

## G1收集器

Garbage-First 

- 并行与并发
- 分代收集
- 空间整理，不会产生内存空间碎片
- 可预测的停顿

它将整个Java堆划分为多个大小相等的独立区域，新生代和老年代不再是无力隔离。

四个步骤：
- 初始标记
- 并发标记
- 最终标记
- 筛选回收

# GC日志

```bash
33.125: [GC [DefNew: 3324K->152K(3712K), 0.0025925 secs] 3324K->152K(11904K), 0.0031680 secs]￼
100.667: [Full GC [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]​​
```

"33.125："和“100.67:” ：代表GC发生的时间

"GC"和“Full GC”：代表这次垃圾收集的停顿类型，Full说明是发生了Stop-The-World。 

“DefNew”和“Tenured”、“Perm”：表示GC发生的区域：
- DefNew：Serial收集器新生代名为“Default New Generation”
- ParNew：ParNew收集器的新生代”Parallel New Generation“
- PSYoungGen：Parallel Scavenge收集器  

DefNew后面的“3324K -> 152K(3712K)”：GC前该内存区域已使用量 -> GC后该内存区域1️已使用量(该内存区域总容量)； 

方括号之外的"3324K -> 152K(11904K)"：表示GC前Java堆已使用容量 -> GC后Java堆已使用容量(Java总容量)。 

“0.0025925 secs”：该内存区域GC所占用的时间，单位是秒； 

有的收集器会给出更具体的时间数据，如“Times: user = 0.01 sys = 0.00 , real = 0.02 secs”，这里user、sys、real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。 

# 垃圾收集相关常用的参数

![垃圾收集相关常用的参数.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202311122350501.png)


# 内存分配与回收策略

## 对象优先分配在Eden

- 新生代GC：Minor GC
- 老年代GC：Major GC/Full GC

## 大对象直接进入老年代

## 长期存活的对象将进入老年代

对象在Survivor区中的年龄（默认15）增加到一定程度就晋升到老年代

## 动态对象年龄判定

如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 

## 空间分配担保

在发生Minor GC之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果成立，就确保Minor GC安全的，如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，如果小于，或者虚拟机参数设置为不允许冒险，将改为Full GC。

总结：如果Minor GC前，老年代的最大可用连续空间小于新生对所有对象总空间，就需要根据条件判断是否要改为Full GC。 

