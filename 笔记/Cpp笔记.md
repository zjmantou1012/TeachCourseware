makefile命令
![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202312081034274.png)

# 指针与引用的区别

指针“指向”内存中的某个对象，而引用“绑定到”内存中的某个对象，它们都实现了对其他对象的间接访问，二者的区别主要有两方面：
1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象；引用不是一个对象，无法令引用重新绑定到另外一个对象。
2. 指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值；引用则必须在定义时赋初值。
3. 参数传递时，不管是传值还是传指针，函数都会产生一个临时副本变量，但在传引用时，不会生成临时变量.
## `*&` 与 `&*`的区别
- `*&`：首先是一个指针，&代表指针的别名，所以代表指针的引用，与指针具有相同地址
- `&*`：首先是一个引用，然后是指向这个引用的指针
## 向函数中传递指针和传递指针的引用的区别

传递指针的引用，即使改变了指针地址，原始指针也会跟着变，而如果传指针的话就不会

如果传递的是指针，那么会先复制该指针，在函数内部使用的是复制后的指针，这个指针与原来的指针虽然指向相同的地址，但是如果在函数内部将复制后的指针指向了另外的地址，那么不会影响原来的指针。 

但是对于传递指针的引用，如果将传递进来的指针指向了新的地址，那么原始的指针也会指向新的地址，这也是为什么在该题中，必须使用指针的引用，而不能使用指针的原因。 

# auto与decltype的主要区别

1. auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。
2. 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，auto一般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const。
3. 与auto不同，decltype的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。