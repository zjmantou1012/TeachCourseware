---
author: zjmantou
title: Cpp笔记
time: 2025-02-27 Thu
tags:
  - 笔记
  - cpp
---
# makefile命令

![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202312081034274.png)

# 指针与引用的区别

指针“指向”内存中的某个对象，而引用“绑定到”内存中的某个对象，它们都实现了对其他对象的间接访问，二者的区别主要有两方面：
1. 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象；引用不是一个对象，无法令引用重新绑定到另外一个对象。
2. 指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值；引用则必须在定义时赋初值。
3. 参数传递时，不管是传值还是传指针，函数都会产生一个临时副本变量，但在传引用时，不会生成临时变量.
## `*&` 与 `&*`的区别
- `*&`：首先是一个指针，&代表指针的别名，所以代表指针的引用，与指针具有相同地址
- `&*`：首先是一个引用，然后是指向这个引用的指针
## 向函数中传递指针和传递指针的引用的区别

传递指针的引用，即使改变了指针地址，原始指针也会跟着变，而如果传指针的话就不会

如果传递的是指针，那么会先复制该指针，在函数内部使用的是复制后的指针，这个指针与原来的指针虽然指向相同的地址，但是如果在函数内部将复制后的指针指向了另外的地址，那么不会影响原来的指针。 

但是对于传递指针的引用，如果将传递进来的指针指向了新的地址，那么原始的指针也会指向新的地址，这也是为什么在该题中，必须使用指针的引用，而不能使用指针的原因。 

# auto与decltype的主要区别

1. auto类型说明符用编译器计算变量的初始值来推断其类型，而decltype虽然也让编译器分析表达式并得到它的类型，但是不实际计算表达式的值。
2. 编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。例如，auto一般会忽略掉顶层const，而把底层const保留下来。与之相反，decltype会保留变量的顶层const。
3. 与auto不同，decltype的结果类型与表达式形式密切相关，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则编译器将推断得到引用类型。

# Lambda表达式

## 基础

基本语法：

[捕获列表]（参数列表）mutable(可选) 异常属性 -> 返回类型 {
	//函数体
}

捕获列表：参数的一种类型，起到传递函数体外部变量；
### 1.值捕获

被捕获的变量在Lambada表达式创建的时就拷贝了。 

### 2.引用捕获

保存的是引用，值会发生变化

### 3.隐式捕获

- []：空捕获列表
- [name1,name2,...]：捕获一系列变量
- [&]：引用捕获，从函数体内的使用确定引用捕获列表
- [=]：值捕获，从函数体内的使用确定值捕获列表
### 4.表达式捕获

C++14允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被声明的捕获变量类型会根据表达式进行判断；

```cpp
#include <iostream>
#include <memory> // std::make_unique
#include <utility> // std::move

void lambda_expression_capture() {
auto important = std::make_unique<int>(1);
auto add = [v1 = 1, v2 = std::move(important)](int x, int y) -> int {
return x+y+v1+(*v2);
};
std::cout << add(3,4) << std::endl;
}
```

## 泛型Lambda

C++14开始，Lambda函数的形式参数可以使用auto：

```cpp
aoto add = [](auto x, auto y) {
	return x + y;
};
add(1,2);
add(1.1,2.2);
```

# 函数对象包装器

## std::function

可调用实体的类型安全的包裹，可以更加方便的将函数、函数指针作为对象处理。

## std::bind 和 std::placeholder

绑定函数调用的参数。 

有时候可能并不一定能够一次性获得调用某个函数的全部参数；

std::placeholder提供占位

```cpp

int foo3(int a, int b, int c) {

return 0;

}

int main() {
	//将参数1，2绑定到函数foo3上
    //但使用 std::placeholders::_1 来对第一个参数进行占位
    auto bindFoo = std::bind(foo3, std::placeholders::_1, 1, 2);
    //这时调用bindFoo时，只需要提供第一个参数即可
    bindFoo(1);
}

	
```

# 右值

- 左值：赋值符号左边的值，是表达式后依然存在的对象；
- 右值：右边的值，表达式结束后就不再存在的临时对象；

## 纯右值

要么是纯粹的字面量，如：10，要么是求值结果相当于字面量或匿名对象，如：1+2； 

非引用返回的临时变量、运算表达式产生的临时变量、 原始字面量、Lambda 表达式都属于纯右值。

字面量出了字符串以外都是右值，字符串类行为 `const char`数组。 

数组可以被隐式转换成相对应的指针类型，而转换表达式的结果（如果不是左值引用）则一定是个右值（右值引用为将亡值，否则为纯右值）

## 将亡值

即将被销毁，却能够被移动的值；

```cpp
std::vector<int> foo() {
    std::vector<int> temp = {1, 2, 3, 4};
    return temp;
}

std::vector<int> v = foo();
```

编译器隐式转换后相当于`static_cast<std::vector<int> &&>(temp)`

右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。 

C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值， 有了它我们就能够方便的获得一个右值临时对象。 

## std:move



## 坍缩规则

在传统 C++ 中，我们不能够对一个引用类型继续进行引用， 但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用， 既能左引用，又能右引用。但是却遵循如下规则：

![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/image/202503022352149.png)

无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型。

## 完美转发 

所谓完美转发，就是为了让我们在传递参数的时候， 保持原来的参数类型（左引用保持左引用，右引用保持右引用）。 为了解决这个问题，我们应该使用 `std::forward` 来进行参数的转发（传递）

**为什么在使用循环语句的过程中，auto&& 是最安全的方式？ 因为当 auto 被推导为不同的左右引用时，与 && 的坍缩组合是完美转发。**

