---
author: zjmantou
title: 鸿蒙笔记
time: 2025-02-11 周二
tags:
  - 鸿蒙
  - ArkTs
---
# 架构层 
## HAP/HAR/HSP 应用场景

[聊聊鸿蒙中 HAR 和 HSP 的使用场景](https://blog.csdn.net/chuyouyinghe/article/details/137112624)
## 导航最佳实践 

[应用导航设计](https://developer.huawei.com/consumer/cn/doc/best-practices-V5/bpta-application-navigation-design-V5#section16766824123214) 
# 并发

## Actor并发模型

Actor并发模型每一个线程都是一个独立Actor，每个Actor有自己独立的内存，Actor之间通过消息传递机制触发对方Actor的行为，不同Actor之间不能直接访问对方的内存空间。

Actor并发模型对比内存共享并发模型的优势在于不同线程间内存隔离，不会产生不同线程竞争同一内存资源的问题。开发者不需要考虑对内存上锁导致的一系列功能、性能问题，提升了开发效率。

由于Actor并发模型线程之间不共享内存，需要通过线程间通信机制传输并发任务和任务结果。

![内存共享模型](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191241.09770119559676004339666238495197:50001231000000:2800:8CB0398572FAAD165E6C61141B472792BF7698E7DB605CF77639BCF027A1A42A.png?needInitFileName=true?needInitFileName=true)

## 异步并发

[Promise和async/await](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/async-concurrency-overview-V5) 

三种状态
- pending：进行中，创建后默认状态；
- fulfilled：已完成；
- rejected：已拒绝

Promise对象可以使用then处理fulfilled和rejected状态：

```ts
import { BusinessError } from '@kit.BasicServicesKit';

promise.then((result: number) => {
 console.info(`Random number is ${result}`);
}).catch((error: BusinessError) => {
 console.error(error.message);
});
```

> [!tip] 当Promise被reject且未通过catch方法来处理时，会触发unhandledrejection事件。可使用errorManager.on('error')接口监听该事件，以全局捕获未处理的Promise reject。

## 多线程并发

Worker 

## 线程间通信 

[官方文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/interthead-communication-V5) 

对于不同的数据对象，在ArkTS线程间通信的行为是有差异的。

- Worker：Actor并发模型标准的跨线程通信API，与Web Worker或者Node.js Worker的使用方式基本一致。
- TaskPool：提供了功能更强、并发编程更简易的任务池API。其中TaskPool涉及跨并发实例的对象传递行为与Worker一致，还是采用了标准的Structured Clone算法，并发通信的对象越大，耗时就越长。
### 线程间通信对象

#### 普通对象

通过拷贝形式传递； 

两个线程的对象内容一致，但是指向各自线程的隔离内存区间，被分配在各自线程的虚拟机本地堆（LocalHeap）；

Object、Array、Map

![普通对象线程间通信](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.32463701159551395452707034620830:50001231000000:2800:1A4677F312AA386A792B5303239CA95B1B8038A430692FF740F4277947BC119D.png?needInitFileName=true?needInitFileName=true)


#### ArrayBuffer对象

内部包含一块Native内存，ArrayBuffer的JS对象壳被分配在虚拟机本地堆（LocalHeap）。
需要经过序列划与反序列化拷贝传递，但是Native内存有两种传输方式：`拷贝`和`转移`。

![拷贝形式](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.82927038734362500123013009798183:50001231000000:2800:A4A68E034A3E404A2FB644FCC0190FFA6F38D44BC43EDA588C3A6FF28B6B6C41.png?needInitFileName=true?needInitFileName=true)


![转移形式](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.85716658638807189003157109127996:50001231000000:2800:5D209ACB8FA02C06C97732D7B6CE7DF47F3B77F4203E1708F1C56253C5E4A913.png?needInitFileName=true?needInitFileName=true)

应用场景：转移图片进行图片处理;

#### SharedArrayBuffer对象

内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。 

支持跨并发实例间共享，但是访问及修改需要采用Atomics类，防止数据竞争。

可以用于多个并发实例间的状态共享或者数据共享。

![SharedArrayBuffer对象通信](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.32097289692477713415967829467439:50001231000000:2800:5664ED3AB20B883638F06F7814D12A97145767D502DC3F87324C2B5F4AA84568.png?needInitFileName=true?needInitFileName=true)

```ts
import { taskpool } from '@kit.ArkTS';

@Concurrent
function transferAtomics(arg1: Int32Array) {
  console.info("wait begin::");
  // 使用Atomics进行操作
  let res = Atomics.wait(arg1, 0, 0, 3000);
  return res;
}

// 定义可共享对象
let sab: SharedArrayBuffer = new SharedArrayBuffer(20);
let int32 = new Int32Array(sab);
let task: taskpool.Task = new taskpool.Task(transferAtomics, int32);
taskpool.execute(task).then((res) => {
  console.info("this res is: " + res);
});
setTimeout(() => {
  Atomics.notify(int32, 0, 1);
}, 1000);
```

#### Transferable对象（NativeBinding对象）

指的是一个JS对象，绑定了一个C++对象，且主体功能由C++提供，其JS对象壳被分配在虚拟机本地堆（LocalHeap）. 

跨线程传输时可以直接复用同一个C++对象，相比于JS对象的拷贝模式，传输效率较高。

##### 共享模式 

如果C++实现能够保证线程安全性，则这个NativeBinding对象的C++部分可以支持共享传输。此时，NativeBinding对象跨线程传输后，只需要重新创建JS壳，就可以桥接到相同的C++对象上。

![共享模式](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.63620466003732083195230847896847:50001231000000:2800:D6140B0179A07B68A058E1ADA688B4CF498AD2FD6A81A8218EED4FD7E35016B0.png?needInitFileName=true?needInitFileName=true)

例如：Context。

示例可参考[使用TaskPool进行频繁数据库操作](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/batch-database-operations-guide-V5#%E4%BD%BF%E7%94%A8taskpool%E8%BF%9B%E8%A1%8C%E9%A2%91%E7%B9%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C)。

##### 转移模式

如果C++实现包含了数据，且无法保证线程安全性，则这个NativeBinding对象的C++部分需要采用转移方式传输。

![转移模式](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.48435662525046737089225756160857:50001231000000:2800:21EAF6F2ED3337092FA2DB11E57FF392B39885048D08205A6020094D7AC7A0DD.png?needInitFileName=true?needInitFileName=true)

例如：[PixelMap对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-image-V5#imagecreatepixelmap8)

#### Sendable对象

在并发通信时支持通过**引用传递**来解决上述问题。 

Sendable对象为可共享的，其跨线程前后指向同一个JS对象，如果其包含了JS或者Native内容，均可以直接共享，如果底层是Native实现的，则需要考虑**线程安全性**。

- **[Sendable对象简介](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-sendable-V5)**      
- **[Sendable使用规则与约束](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/sendable-constraints-V5)**  
- **[异步锁](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-async-lock-introduction-V5)**  
- **[ASON解析与生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ason-parsing-generation-V5)**  
- **[共享容器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-collections-introduction-V5)**  
- **[共享模块](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-sendable-module-V5)**  
- **[Sendable对象冻结](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/sendable-freeze-V5)**  
- **[Sendable使用场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/sendable-guide-V5)**

由于ArkTS语言支持异步操作，阻塞锁容易产生死锁问题，因此在ArkTS中**仅支持**异步锁（非阻塞式锁）。


[共享容器与原生API方法的行为差异对比](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-collections-introduction-V5#共享容器与原生api方法的行为差异对比) 

使用场景：
- 传输大数据
- 传递带方法的class实例对象，传输对象丢失方法，需使用引用传递。
### 线程间通信场景

- **[使用TaskPool执行独立的耗时任务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/independent-time-consuming-task-V5)**  
- **[使用TaskPool执行多个耗时任务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/multi-time-consuming-tasks-V5)**  
- **[TaskPool任务与宿主线程通信](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/taskpool-communicates-with-mainthread-V5)**  
- **[Worker和宿主线程的即时消息通信](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/worker-communicates-with-mainthread-V5)**  
- **[Worker同步调用宿主线程的接口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/worker-invoke-mainthread-interface-V5)**

# 工程包

## Stage模型与FA模型

[Stage与FA模型区别](https://developer.huawei.com/consumer/cn/forum/topic/0202105111455550468) 

# ArkUI

## 生命周期 

![页面及组件生命周期](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250213113535.89466154540883457558190218673733:50001231000000:2800:4FCC814E0722F5BB92DF71F2F27BC86A860F4663BE7048093581FCAA8525F0B5.png?needInitFileName=true?needInitFileName=true)

[页面及自定义组件生命周期](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-page-custom-components-lifecycle-V5) 

## 自定义布局 

- [onMeasureSize](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/ts-custom-component-layout-V5#onmeasuresize10)：组件每次布局时触发，计算子组件的尺寸，其执行时间先于onPlaceChildren。    
- [onPlaceChildren](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/ts-custom-component-layout-V5#onplacechildren10)：组件每次布局时触发，设置子组件的起始位置。

## @LocalBuilder
子组件引用父组件的@LocalBuilder函数，传入的参数为状态变量，状态变量的改变不会引发@LocalBuilder方法内的UI刷新，原因是@Localbuilder装饰的函数绑定在父组件上，状态变量刷新机制是刷新本组件以及其子组件，对父组件无影响，故无法引发刷新。若使用@Builder修饰则可引发刷新，**原因是@Builder改变了函数的this指向，此时函数被绑定到子组件上，故能引发UI刷新**。

使用场景：

组件Child将@State修饰的label值按照函数传参方式传递到Parent的@Builder和@LocalBuilder函数内，在被@Builder修饰的函数内，this指向Child，参数变化能引发UI刷新，在被@LocalBuilder修饰的函数内，this指向Parent，参数变化不能引发UI刷新。

```ts
class LayoutSize {
  size:number = 0;
}

@Entry
@Component
struct Parent {
  label:string = 'parent';
  @State layoutSize:LayoutSize = {size:0};

  @LocalBuilder
  // @Builder
  componentBuilder($$:LayoutSize) {
    Text(`${'this :'+this.label}`);
    Text(`${'size :'+$$.size}`);
  }

  build() {
    Column() {
      Child({contentBuilder: this.componentBuilder });
    }
  }
}

@Component
struct Child {
  label:string = 'child';
  @BuilderParam contentBuilder:((layoutSize: LayoutSize) => void);
  @State layoutSize:LayoutSize = {size:0};

  build() {
    Column() {
      this.contentBuilder({size: this.layoutSize.size});
      Button("add child size").onClick(()=>{
        this.layoutSize.size += 1;
      })
    }
  }
}
```

[@LocalBuilder和@Builder区别说明](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-localbuilder-V5#localbuilder和builder区别说明)

## @BuilderParam

[尾随闭包](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-builderparam-V5#尾随闭包初始化组件)

## [wrapBuilder：封装全局@Builder](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-wrapbuilder-V5)

当开发者在一个struct内使用了多个全局@Builder函数，来实现UI的不同效果时，多个全局@Builder函数会使代码维护起来非常困难，并且页面不整洁。此时，开发者可以使用wrapBuilder来封装全局@Builder。

[@Builder方法赋值给变量在UI语法中使用](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-wrapbuilder-V5#builder方法赋值给变量在ui语法中使用)

## 样式

### @Styles VS @Extend
- @Styles：重用组件样式
	- 不支持传值
	- 支持全局定义和组件内定义
- @Extend：扩展组件样式
	- 支持传值，参数支持function、event句柄、状态变量
	- 仅支持全局定义，只能在当前文件定义，不能使用export

### @Styles VS stateStyles

@Styles仅支持静态页面复用，stateStyles可以依据组件的内部状态的不同，stateStyles时属性方法。

有五种状态：
- focused：获焦态。
- normal：正常态。
- pressed：按压态。
- disabled：不可用态。
- selected10+：选中态。

## 动画属性@AnimatableExtend

- 仅支持全局定义
- 参数必须为number或者实现`AnimatableArithmetic<T>`接口的自定义类型
- 函数体内只能调用@AnimatableExtend括号内组件的属性方法。
## AnimatableArithmetic接口说明

对非number类型的数据（如数组、结构体、颜色等）做动画，需要实现`AnimatableArithmetic<T>`接口中加法、减法、乘法和判断相等函数. 

- plus
- subtract
- multiply
- equals

## 组件复用@Reusable

记为@Reusable的自定义组件从组件树上被移除时，组件和其对应的JSView对象都会被放入复用缓存中，后续创建新自定义组件节点时，会复用缓存区中的节点，节约组件重新创建的时间。

- 仅用于自定义组件
- ComponentContent不支持传入@Reusable装饰器装饰的自定义组件
- @Reusable装饰器不支持嵌套使用，存在增加内存和不方便维护的问题；

### 使用场景

- 列表滚动
- 动态布局更新：频繁的进行布局更新
- 频繁创建和销毁数据项的视图
# 状态管理

## @Observed V1与V2区别

- V1无法对嵌套类对象属性变化进行直接观测，需要使用[@ObjectLink装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-observed-and-objectlink-V5)与自定义组件的方式实现观测。

### V2观测范围

- 嵌套类中@Trace属性
- 继承类中使用@Trace的属性
- 类中使用@Trace的静态属性
- 观察api变化：
	- Array：push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort
	- Date：setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds
	- Map：set, clear, delete
	- Set：add, clear, delete

### V2限制
- 非@Trace装饰的成员属性用在UI上无法触发UI刷新。
- @ObservedV2仅能装饰class，无法装饰自定义组件。
- @Trace不能用在没有被@ObservedV2装饰的class上。
- @Trace是class中属性的装饰器，不能用在struct中。
- @ObservedV2、@Trace不能与@Observed、@Track混合使用。
- 使用@ObservedV2与@Trace装饰的类不能和@State等V1的装饰器混合使用。
- 继承自@ObservedV2的类无法和@State等V1的装饰器混用，运行时报错。
- **@ObservedV2的类实例目前不支持使用JSON.stringify进行序列化。**

### V2使用场景

- 嵌套类
- 继承类
- Array、Map、Set、Date

## @ComponentV2与@Component混用

[混用文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-custom-component-mixed-scenarios-V5)。

## @Local

- 必须在组件内初始化
- 被@Local修饰的变量变化时能够刷新使用了该变量的组件
- 支持观测number、boolean、string、Object、class等基本类型以及Array、Set、Map、Date等内嵌类型。
- 支持null、undefined以及联合类型

### @State局限性

不能感知到值从外部初始化

### VS @State

|         | @State                   | @Local                   |
| :------ | :----------------------- | ------------------------ |
| 参数      | 无。                       | 无。                       |
| 从父组件初始化 | 可选。                      | 不允许外部初始化。                |
| 观察能力    | 能观测变量本身以及一层的成员属性，无法深度观测。 | 能观测变量本身，深度观测依赖@Trace装饰器。 |
| 数据传递    | 可以作为数据源和子组件中状态变量同步。      | 可以作为数据源和子组件中状态变量同步。      |

### 问题

[复杂类型常量重复赋值给状态变量触发刷新](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-new-local-V5#复杂类型常量重复赋值给状态变量触发刷新)

建议开发者在状态管理V2中谨慎使用animateTo接口。

# 框架对比

[Navigation VS Router](https://developer.huawei.com/consumer/cn/doc/harmonyos-faqs/faqs-arkui-299-V5) 

