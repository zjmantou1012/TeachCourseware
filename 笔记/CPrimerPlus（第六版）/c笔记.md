《C Primer Plus（第6版）中文版【最新修订版】》
史蒂芬·普拉达
167个笔记

◆ 10.3 指针和数组

>> C中，指针加1指的是增加一个存储单元。对数组而言，这意味着加1后的地址是下一个元素的地址，而不是下一个字节的地址（见图10.3）。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道存储对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则*pt就无法正确地取回地址上的值）

>> 指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如double类型的变量）通常是该对象第一个字节的地址。

>> 在指针前面使用*运算符可以得到该指针所指向对象的值。

>> 指针加1，指针的值递增它所指向类型的大小（以字节为单位）。

◆ 10.7 指针和多维数组

>> C++允许在声明数组大小时使用const整数，而C却不允许

>> C++不允许把const指针赋给非const指针。而C则允许这样做，但是如果通过p1更改y，其行为是未定义的。

◆ 10.8 变长数组（VLA）

>> 可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：

◆ 第11章 字符串和字符串函数

>> 函数——gets()、gets_s()、fgets()、puts()、fputs()、strcat()、 strncat()、strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr()；

◆ 11.2 字符串输入

>> 如果使用%s转换说明，以下一个空白字符（空行、空格、制表符或换行符）作为字符串的结束（字符串不包括空白字符）。

>> scanf()和gets()类似，也存在一些潜在的缺点。如果输入行的内容过长，scanf()也会导致数据溢出。不过，在%s转换说明中使用字段宽度可防止溢出。

◆ 11.5 字符串函数

>> 这说明，如果在字母表中第1个字符串位于第2个字符串前面，strcmp()中就返回负数；反之，strcmp()则返回正数。所以，strcmp()比较"C"和"A"，返回1。

>> strcmp()函数比较的是字符串，不是字符，所以其参数应该是字符串（如"apples"和"A"），而不是字符（如'A'）。但是，char类型实际上是整数类型，所以可以使用关系运算符来比较字符。

>> strncmp()函数在比较两个字符串时，可以比较到字符不同的地方，也可以只比较第3个参数指定的字符数。

>> 拷贝字符串用strncpy()更安全，该函数的第3个参数指明可拷贝的最大字符数。

>> sprintf()函数声明在stdio.h中，而不是在string.h中。该函数和printf()类似，但是它是把数据写入字符串，而不是打印在显示器上。

>> ANSI C库有20多个用于处理字符串的函数，下面总结了一些常用的函数。

◆ 11.9 把字符串转换为数字

>> atoi()函数（用于把字母数字转换成整数）

>> 如果字符串仅以整数开头，atoi()函数也能处理，它只把开头的整数转换为字符。

>> atof()函数把字符串转换成double类型的值，atol()函数把字符串转换成long类型的值。

>> strtol()把字符串转换成long类型的值，strtoul()把字符串转换成unsigned long类型的值，strtod()把字符串转换成double类型的值。这些函数的智能之处在于识别和报告字符串中的首字符是否是数字。而且，strtol()和strtoul()还可以指定数字的进制。

◆ 第12章 存储类别、链接和内存管理

>> 关键字——auto、extern、static、register、const、volatile、restricted、 _Thread_local、_Atomic；

>> 函数——rand()、srand()、time()、malloc()、calloc()、free()；

◆ 12.4 分配内存：malloc()和free()

>> 我们有3种创建数组的方法

>> 声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元素。可以用静态内存或自动内存创建这种数组

>> 声明变长数组（C99新增的特性）时，用变量表达式表示数组的维度，用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。

>> 声明一个指针，调用malloc()，将其返回值赋给指针，使用指针访问数组的元素。该指针可以是静态的或自动的

>> 动态分配内存的存储期从调用malloc()分配内存到调用free()释放内存为止

>> 如果内存分配失败，可以调用exit()函数结束程序，其原型在stdlib.h中

>> C中，不一定要使用强制类型转换(double *)，但是在C++中必须使用。所以，使用强制类型转换更容易把C程序转换为C++程序

2023/12/02发表想法

>> if (ptd == NULL) {      puts("Memory allocation failed. Goodbye.");      exit(EXIT_FAILURE); }
如果程序成功分配内存，便可把ptd视为一个有max个元素的数组名。
注意，free()函数位于程序的末尾，它释放了malloc()函数分配的内存。free()函数只释放其参数指向的内存块。一些操作系统在程序结束时会自动释放动态分配的内存，但是有些系统不会。为保险起见，请使用free()，不要依赖操作系统来清理。
使用动态数组有什么好处？从本例来看，使用动态数组给程序带来了更多灵活性。假设你已经知道，在大多数情况下程序所用的数组都不会超过100个元素，但是有时程序确实需要10000个元素。要是按照平时的做法，你不得不为这种情况声明一个内含10000个元素的数组。基本上这样做是在浪费内存。如果需要10001个元素，该程序就会出错。这种情况下，可以使用一个动态数组调整程序以适应不同的情况。
12.4.1　free()的重要性
静态内存的数量在编译时是固定的，在程序运行期间也不会改变。

>> 静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存数量只会增加，除非用free()进行释放。

>> calloc()函数还有一个特性：它把块中的所有位都设置为0（注意，在某些硬件系统中，不是把所有位都设置为0来表示浮点值0）。

>> 变长数组是自动存储类型。因此，程序在离开变长数组定义所在的块时（该例中，即vlamal()函数结束时），变长数组占用的内存空间会被自动释放，不必使用free()。

>> 程序把静态对象、自动对象和动态分配的对象存储在不同的区域。

◆ 12.5 ANSI C类型限定符

>> restrict，用于提高编译器优化

>> const放在*左侧任意位置，限定了指针指向的数据不能改变；const放在*的右侧，限定了指针本身不能改变。

>> 在文件间共享const数据要小心。可以采用两个策略。第一，遵循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使用引用式声明（用extern关键字）：

>> 另一种方案是，把const变量放在一个头文件中，然后在其他文件中包含该头文件：

>> 头文件方案的好处是，方便你偷懒，不用惦记着在一个文件中使用定义式声明，在其他文件中使用引用式声明。所有的文件都只需包含同一个头文件即可。但它的缺点是，数据是重复的。对于前面的例子而言，这不算什么问题，但是如果const数据包含庞大的数组，就不能视而不见了。

>> volatile限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。

>> 可以同时用const和volatile限定一个值

>> restrict关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。

>> 这是因为for循环在par两次访问相同的数据之间，用ar改变了该数据的值。

>> memcpy()函数要求两个位置不重叠，但是memmove()没有这样的要求。

>> restrict关键字有两个读者。一个是编译器，该关键字告知编译器可以自由假定一些优化方案。另一个读者是用户，该关键字告知用户要使用满足restrict要求的参数。

>> double stick(double ar[static 20]);
static的这种用法表明，函数调用中的实际参数应该是一个指向数组首元素的指针，且该数组至少有20个元素。

◆ 13.1 与文件进行通信

>> 所有文件的内容都以二进制形式（0或1）存储。但是，如果文件最初使用二进制编码的字符（例如，ASCII或Unicode）表示文本（就像C字符串那样），该文件就是文本文件，其中包含文本内容。如果文件中的二进制值代表机器语言代码或数值数据（使用相同的内部表示，假设，用于long或double类型的值）或图片或音乐编码，该文件就是二进制文件，其中包含二进制内容。

>> C提供两种访问文件的途径：二进制模式和文本模式。在二进制模式中，程序可以访问文件的每个字节。而在文本模式中，程序所见的内容和文件的实际内容不同

>> 程序以文本模式读取文件时，把本地环境表示的行末尾或文件结尾映射为C模式

>> 除了选择文件的模式，大多数情况下，还可以选择I/O的两个级别（即处理文件访问的两个级别）

>> 底层I/O（low-level I/O）

>> 使用操作系统提供的基本I/O服务。

>> 标准高级I/O（standard high-level I/O）

>> 使用C库的标准包和stdio.h头文件定义。

>> C程序会自动打开3个文件，它们被称为标准输入（standard input）、标准输出（standard output）和标准错误输出（standard error output）。

◆ 13.2 标准I/O

>> 标准I/O包除了可移植以外还有两个好处

>> 第一，标准I/O有许多专门的函数简化了处理不同I/O的问题。

>> 第二，输入和输出都是缓冲的。

>> 新的C11新增了带x字母的写模式

>> FILE是一个定义在stdio.h中的派生类型。文件指针fp并不指向实际的文件，它指向一个包含文件信息的数据对象，其中包含操作文件的I/O函数所用的缓冲区信息。

◆ 13.6 标准I/O的机理

>> fopen()函数不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。

>> 文件位置指示器被设置为指向刚读取字符的下一个字符。

◆ 13.7 其他标准I/O函数

>> 调用fflush()函数引起输出缓冲区中所有的未写入数据被发送到fp指定的输出文件。

>> fread()和fwrite函数用于以二进制形式处理数据

>> feof()和ferror()函数用于区分这两种情况。当上一次输入调用检测到文件结尾时，feof()函数返回一个非零值，否则返回0。当读或写出现错误，ferror()函数返回一个非零值，否则返回0。

>> 13.7.8　一个程序示例

◆ 14.7 向函数传递结构的信息

>> 指针作为参数有两个优点：无论是以前还是现在的C实现都能使用这种方法，而且执行起来很快，只需要传递一个地址。缺点是无法保护数据。被调函数中的某些操作可能会意外影响原来结构中的数据。不过，ANSI C新增的const限定符解决了这个问题。例如，如果在程序清单14.8中，showinfo()函数中的代码改变了结构的任意成员，编译器会捕获这个错误。

>> 结构作为参数传递的优点是，函数处理的是原始数据的副本，这保护了原始数据。另外，代码风格也更清楚。假设定义了下面的结构类型：

>> 传递结构的两个缺点是：较老版本的实现可能无法处理这样的代码，而且传递结构浪费时间和存储空间。尤其是把大型结构传递给函数，而它只使用结构中的一两个成员时特别浪费。这种情况下传递指针或只传递函数所需的成员更合理。

>> 声明一个struct flex类型的结构变量时，不能用scores做任何事，因为没有给这个数组预留存储空间。实际上，C99的意图并不是让你声明struct flex类型的变量，而是希望你声明一个指向struct flex类型的指针，然后用malloc()来分配足够的空间，以存储struct flex类型结构的常规内容和伸缩型数组成员所需的额外空间。例如，假设用scores表示一个内含5个double类型值的数组，可以这样做

>> struct flex * pf;    // 声明一个指针￼ // 请求为一个结构和一个数组分配存储空间￼ pf = malloc(sizeof(struct flex) + 5 * sizeof(double));

>> 带伸缩型数组成员的结构确实有一些特殊的处理要求

>> 第一，不能用结构进行赋值或拷贝

>> 第二，不要以按值方式把这种结构传递给结构。

>> 第三，不要使用带伸缩型数组成员的结构作为数组成员或另一个结构的成员。

>> 这种类似于在结构中最后一个成员是伸缩型数组的情况，称为struct hack。

>> 匿名结构是一个没有名称的结构成员。为了理解它的工作原理，我们先考虑如何创建嵌套结构：

◆ 14.10 联合简介

>> 联合只能存储一个值，这与结构不同。

>> 匿名联合和匿名结构的工作原理相同，即匿名联合是一个结构或联合的无名联合成员。

◆ 14.11 枚举类型

>> 枚举类型的目的是提高程序的可读性。它的语法与结构的语法相同

>> C枚举的一些特性并不适用于C++。例如，C允许枚举变量使用++运算符，但是C++标准不允许。所以，如果编写的代码将来会并入C++程序，那么必须把上面例子中的color声明为int类型，才能C和C++都兼容。

◆ 14.12 typedef简介

>> typedef工具是一个高级数据特性，利用typedef可以为某一类型自定义名称。这方面与#define类似，但是两者有3处不同：
● 与#define不同，typedef创建的符号名只受限于类型，不能用于值。
● typedef由编译器解释，不是预处理器。
● 在其受限范围内，typedef比#define更灵活。

>> 假设要用BYTE表示1字节的数组。只需像定义个char类型变量一样定义BYTE，然后在定义前面加上关键字typedef即可：

>> typedef的一些特性与#define的功能重合。例如：
#define BYTE unsigned char
这使预处理器用BYTE替换unsigned char。但是也有#define没有的功能：
typedef char * STRING;
没有typedef关键字，编译器将把STRING识别为一个指向char的指针变量。有了typedef关键字，编译器则把STRING解释成一个类型的标识符，该类型是指向char的指针。因此：
STRING name, sign;
相当于：
char * name, * sign;
但是，如果这样假设：
#define STRING char *
然后，下面的声明：
STRING name, sign;
将被翻译成：
char * name, sign;
这导致只有name才是指针。

>> 为经常出现的类型创建一个方便、易识别的类型名。

2023/12/03发表想法

>> rect r1 = {3.0, 6.0}; rect r2;
以上代码将被翻译成：
struct {double x; double y;} r1= {3.0, 6.0}; struct {double x; double y;} r2; r2 = r1;
这两个结构在声明时都没有标记，它们的成员完全相同（成员名及其类型都匹配），C认为这两个结构的类型相同，所以r1和r2间的赋值是有效操作。
使用typedef的第2个原因是：typedef常用于给复杂的类型命名。例如，下面的声明：
typedef char (* FRPTC ()) [5];
把FRPTC声明为一个函数类型，该函数返回一个指针，该指针指向内含5个char类型元素的数组（参见下一节的讨论）。
使用typedef时要记住，typedef并没有创建任何新类型，它只是为某个已存在的类型增加了一个方便使用的标签。以前面的STRING为例，这意味着我们创建的STRING类型变量可以作为实参传递给以指向char的指针作为形参的函数。

>> typedef常用于给复杂的类型命名。例如，下面的声明：
typedef char (* FRPTC ()) [5];

◆ 14.13 其他复杂的声明

>> int board[8][8];       // 声明一个内含int数组的数组￼ int ** ptr;            // 声明一个指向指针的指针，被指向的指针指向int￼ int * risks[10];       // 声明一个内含10个元素的数组，每个元素都是一个指向int的指针￼ int (* rusks)[10];     // 声明一个指向数组的指针，该数组内含10个int类型的值￼ int * oof[3][4];       // 声明一个3×4 的二维数组，每个元素都是指向int的指针￼ int (* uuf)[3][4];     // 声明一个指向3×4二维数组的指针，该数组中内含int类型值￼ int (* uof[3])[4];     // 声明一个内含3个指针元素的数组，其中每个指针都指向一个内含4个int类￼

◆ 14.14 函数和指针

>> 函数指针常用作另一个函数的参数，告诉该函数要使用哪一个函数

>> void (*pf)(char *);    // pf 是一个指向函数的指针

>> void *pf(char *); // pf 是一个返回字符指针的函数

◆ 15.3 C按位运算符

>> 二进制反码或按位取反：～

>> 按位与：&

>> 按位或：|

>> 按位异或：^

>> 用法：掩码

>> 按位与运算符常用于掩码（mask）。

>> 用法：打开位（设置位）

>> 必须打开1号位，同时保持其他位不变。这种情况可以使用按位或运算符（|）

>> 用法：关闭位（清空位）

>> flags = flags & ～MASK;

>> 用法：切换位

>> 切换位指的是打开已关闭的位，或关闭已打开的位。可以使用按位异或运算符（^）切换位。

>> 用法：检查位的值

>> if ((flags & MASK) == MASK)￼

>> 左移：<<

>> 右移：>>

>> 用法：移位运算符

>> 移位运算符针对2的幂提供快速有效的乘法和除法：

>> 移位运算符还可用于从较大单元中提取一些位

◆ 15.4 位字段

>> 位字段是一个signed int或unsigned int类型变量中的一组相邻的位（C99和C11新增了_Bool类型的位字段）。

>> 如果声明的总位数超过了一个unsigned int类型的大小会怎样？

>> 可以用未命名的字段宽度“填充”未命名的“洞”。使用一个宽度为0的未命名字段迫使下一个字段与下一个整数对齐：
struct {￼      unsigned int field1    : 1 ;￼      unsigned int           : 2 ;￼      unsigned int field2    : 1 ;￼      unsigned int           : 0 ;￼      unsigned int field3    : 1 ;￼ } stuff;

◆ 15.5 对齐特性（C11）

>> _Alignof运算符给出一个类型的对齐要求，在关键字_Alignof后面的圆括号中写上类型名即可：

>> C11在stdlib.h库还添加了一个新的内存分配函数，用于对齐动态分配的内存。该函数的原型如下：
void *aligned_alloc(size_t alignment, size_t size);

◆ 16.2 明示常量：#define

>> 预处理器指令从#开始运行，到后面的第1个换行符为止。也就是说，指令的长度仅限于一行。

>> “无效”注释。在C中，非自动数组的大小应该是整型常量表达式，这意味着表示数组大小的必须是整型常量的组合（如5）、枚举常量和sizeof表达式，不包括const声明的值（这也是C++和C的区别之一，在C++中可以把const值作为常量表达式的一部分）。

◆ 16.3 在#define中使用参数

>> 在#define中使用参数

>> 导致这样结果的原因是，我们前面提到过，预处理器不做计算、不求值，只替换字符序列。预处理器把出现x的地方都替换成x+2。因此，x*x变成了x+2*x+2。如果x为5，那么该表达式的值为：

>> 必要时要使用足够多的圆括号来确保运算和结合的正确顺序。

>> 用宏参数创建字符串：#运算符

>> 调用第1个宏时，用"y"替换#x。调用第2个宏时，用"2 + 4"替换#x。ANSI C字符串的串联特性将这些字符串与printf()语句的其他字符串组合，生成最终的字符串。

>> 预处理器黏合剂：##运算符

>> 与#运算符类似，##运算符可用于类函数宏的替换部分。而且，##还可用于对象宏的替换部分。##运算符把两个记号组合成一个记号

>> 变参宏：...和_ _VA_ARGS_ _

>> 通过把宏参数列表中最后的参数写成省略号（即，3个点...）来实现这一功能。这样，预定义宏
_ _VA_ARGS_ _可用在替换部分中，表明省略号代表什么。例如，下面的定义：
#define PR(...) printf(_ _VA_ARGS_ _)

◆ 16.4 宏和函数的选择

>> 宏和函数的选择实际上是时间和空间的权衡。宏生成内联代码，即在程序中生成语句。

>> 如果调用20次宏，即在程序中插入20行代码。如果调用函数20次，程序中只有一份函数语句的副本，所以节省了空间。然而另一方面，程序的控制必须跳转至函数内，随后再返回主调程序，这显然比内联代码花费更多的时间

>> 宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而不是实际的值）。因此，只要能用int或float类型都可以使用SQUARE(x)宏。

>> ● 记住宏名中不允许有空格，但是在替换字符串中可以有空格。ANSI C允许在参数列表中使用空格。

>> ● 用圆括号把宏的参数和整个替换体括起来。这样能确保被括起来的部分在下面这样的表达式中正确地展开：

>> ● 用大写字母表示宏函数的名称。

>> ● 如果打算使用宏来加快程序的运行速度，那么首先要确定使用宏和使用函数是否会导致较大差异。在程序中只使用一次的宏无法明显减少程序的运行时间。在嵌套循环中使用宏更有助于提高效率。许多系统提供程序分析器以帮助程序员压缩程序中最耗时的部分。

◆ 16.5 文件包含：#include

>> 在UNIX系统中，尖括号告诉预处理器在标准系统目录中查找该文件。双引号告诉预处理器首先在当前目录中（或文件名中指定的其他目录）查找该文件，如果未找到再查找标准系统目录

>> 在大部分情况下，头文件的内容是编译器生成最终代码时所需的信息，而不是添加到最终代码中的材料。

◆ 16.6 其他指令

>> 程序员可能要为不同的工作环境准备C程序和C库包。不同的环境可能使用不同的代码类型。预处理器提供一些指令，程序员通过修改#define的值即可生成可移植的代码

>> #undef指令取消之前的#define定义。#if、#ifdef、#ifndef、#else、#elif和#endif指令用于指定什么情况下编译哪些代码。#line指令用于重置行和文件信息，#error指令用于给出错误消息，#pragma指令用于向编译器发出指令。

>> 如果想使用一个名称，又不确定之前是否已经用过，为安全起见，可以用#undef指令取消该名字的定义

>> 条件编译

>> #ifdef、#else和#endif指令

>> #ifndef指令

>> #ifndef指令与#ifdef指令的用法类似，也可以和#else、#endif一起使用，但是它们的逻辑相反。#ifndef指令判断后面的标识符是否是未定义的，常用于定义之前未定义的常量。

>> 通常，包含多个头文件时，其中的文件可能包含了相同宏定义。#ifndef指令可以防止相同的宏被重复定义。

>> #ifndef指令通常用于防止多次包含一个文件

>> #if和#elif指令

>> 泛型选择（C11）

>> 下面是一个把泛型选择语句和宏定义组合的例子：

◆ 16.7 内联函数（C99）

>> 内联函数（C99）

>> 函数调用都有一定的开销，因为函数的调用过程包括建立调用、传递参数、跳转到函数代码并返回

>> 函数变成内联函数，编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用。

>> 标准规定具有内部链接的函数可以成为内联函数，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中。因此，最简单的方法是使用函数说明符inline和存储类别说明符static。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相当于函数原型。

>> 内联函数应该比较短小。把较长的函数变成内联并未节约多少时间，因为执行函数体的时间比调用函数的时间长得多。

>> 因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。

>> 如果像file3.c那样，省略file1.c文件inline定义中的static，那么该inline定义被视为可替换的外部定义。

◆ 16.8 _Noreturn函数（C11）

>> _Noreturn函数（C11）

>> exit()函数是_Noreturn函数的一个示例

>> _Noreturn的目的是告诉用户和编译器，这个特殊的函数不会把控制返回主调程序。告诉用户以免滥用该函数，通知编译器可优化一些代码。

◆ 16.10 数学库

>> 有趣的一点是，如何让_Generic宏的行为像一个函数。SIN()的定义也许提供了一个方法：每个带标号的值都是函数调用，所以_Generic表达式的值是一个特定的函数调用，如sinf((X)/RAD_TO_DEG)，用传入SIN()的参数替换X。
SQRT()的定义也许更简洁。_Generic表达式的值就是函数名，如sinf。函数的地址可以代替该函数名，所以_Generic表达式的值是一个指向函数的指针。然而，紧随整个_Generic表达式之后的是(X)，函数指针(参数)表示函数指针。因此，这是一个带指定的参数的函数指针。

◆ 16.11 通用工具库

>> 通用工具库

>> atexit()通过注册要在退出时调用的函数来提供这一特性，atexit()函数接受一个函数指针作为参数。

>> 最后调用exit()函数时，exit()会执行这些函数（执行顺序与列表中的函数顺序相反，即最后添加的函数最先执行）。

◆ 16.12 断言库

>> 使用assert()有几个好处：它不仅能自动标识文件和出问题的行号，还有一种无需更改代码就能开启或关闭assert()的机制。如果认为已经排除了程序的bug，就可以把下面的宏定义写在包含assert.h的位置前面：

>> _Static_assert声明，可以在编译时检查assert()表达式

◆ 16.13 string.h库中的memcpy()和memmove()

>> memcpy()的参数带关键字restrict，即memcpy()假设两个内存区域之间没有重叠；而memmove()不作这样的假设，所以拷贝过程类似于先把所有字节拷贝到一个临时缓冲区，然后再拷贝到最终目的地。

◆ 16.14 可变参数：stdarg.h

>> 可变参数：stdarg.h

>> 必须按如下步骤进行：
1．提供一个使用省略号的函数原型；
2．在函数定义中创建一个va_list类型的变量；
3．用宏把该变量初始化为一个参数列表；
4．用宏访问参数列表；
5．用宏完成清理工作。

◆ 17.3 抽象数据类型（ADT）

2023/12/05发表想法
这里应该是*plist =NULL，缺少一个星号
>> plist = NULL;
