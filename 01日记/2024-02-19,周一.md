---
author: zjmantou
title: 2024-02-19,周一
time: 2024-02-19 周一
tags:
  - Android
  - 笔记
  - 面试
  - 日记
---


# 小鹏面试经验

## handler 同步屏障
Message消息分类：
- 同步消息：最普通常用的
- 同步屏障：插入屏障（postSyncBarrier）后只处理异步消息，与同步消息的区别是没有设置target属性；
- 异步消息：通过构造函数async设置异步，或者直接调用setAsynchronous方法设置消息为异步；
### 应用场景
绘制流程中的requestLayout方法，scheduleTraversals方法里会插入一个同步屏障，Choreographer插入的消息是异步消息。 

### 参考链接
[什么是Handler的同步屏障机制](https://juejin.cn/post/6971981915934949390)


## zygote进程的socket作用，为什么不用binder

1. **时序问题**：如果在zygote中注册binder，这时候servicemanager中不一定初始化完成，有可能拿不到binder；
2. **多线程问题**：不推荐fork多线程进程，binder服务是多线程的进程（调用服务所在线程就是调用对象所在的线程），使用binder会导致fork一个多线程进程。
3. **效率问题**：AMS和Zygote之间使用的**LocalSocket**，相对于网络Socket，减少了数据验证等环节，所以其实效率相对于正常的网络Socket会大幅的提升。虽然还是要经过两次拷贝，但是由于数据量并不大，所以其实影响并不明显。
4. **Binder拷贝问题**：Binder的C/S架构特性，导致binder是成对存在的，使用socket通信，fork出app进程后，app进程会去主动关闭掉这个Socket释放这块区域，而如果使用binder的话就无法释放这块区域。

### 参考链接

[Zygote进程通信为什么用Socket而不是Binder?](https://zhuanlan.zhihu.com/p/664948640)

## binder线程池

[进程的Binder线程池工作过程](http://gityuan.com/2016/10/29/binder-thread-pool/)

## livedata的粘性消息过程

判断LiveData中mVersion与观察者封装类ObserverWrapper中的mLastVersion的值的大小，大于就发送最新值。

### 产生的问题（数据倒灌）

现象：在activity销毁重建时，会把最新的数据自动发送给activity的观察者；

原理： 

一个Livedata维护着一个mVersion。每次setValue时都会+1，每个观察者封装的ObserverWrapper类中也有一个mLastVersion，如果mVersion的值大于mLastVersion的值，就会强制把值推送给观察者，当屏幕旋转的时候，ObserverWrapper中的mLastVersion值变为初始值-1了。

### 解决方法

1. 继承LiveData重新封装observe方法和setValue方法，自己写数据变化的判断逻辑（比如用布尔值）改变之后仔调用onChange；
2. 反射或者livedata版本号，再反射修改observe版本号；
3. 个人思路：livedata应该只寸state，而不是通过livedata字段去进行事件动作处理。

 