# 涂鸦面试

## AIDL中的回调类是什么类

是一个aidl的Stub类，Binder的子类

## ConcurrentHashMap 可以两个线程同时写吗？适合什么场景，不适合什么场景?

ConcurrentHashMap只能保证提供的原子性读写操作是线程安全的。
也就是put()、get()操作是线程安全的。这两个操作对于多线程同时操作，线程之间是可见的，因为ConcurrentHashMap.Node.val和因为ConcurrentHashMap.baseCount被volatile修饰。

如何正确使用：
- ConcurrentHashMap#putIfAbsent()，实现get()、put()原子性操作，因为 ConcurrentHashMap#putIfAbsent() 方法内部加了synchronized锁

## 重入锁可以代替synchronized吗

可以，重入锁更加灵活，一个ReentrantLock可以有多个条件对象

核心问题场景： 当一个线程获得当前实例的锁lock,并且进入了方法A，该线程在方法A没有释放该锁的时候，是否可以再次使用该锁的方法B？

### 不可重入锁

当线程在访问A方法的时候，获取的A方法的锁，在A方法锁释放之前不能够访问其他方法（如方法B）的锁。

不可重入锁模型：｛｝｛｝｛｝｛｝｛｝都是独立的访问每一个方法，加锁 - 释放；加锁 - 释放。。。

### 可重入锁

当线程在访问A方法的时候，获取A方法的锁，然后访问B方法获取B方法的锁，并计数加1，以此类推可以访问完了以后依次解锁。

可重入锁模型：｛｛｛｛｝｝｝｝ 每次都可访问另一个方法，且加锁计数器加1，完全释放锁为计数器等于0


目的：防止死锁，导致同一个线程不可重入上锁代码段


## 序列化区别

![[序列化-Serializable和Parcelable]]