---
author: zjmantou
title: 2023-11-06,面试记录——相芯
time: 2023-11-06 周一
tags:
  - Android
  - 面试
---


# aidl通讯过程
[深入理解Binder机制1-AIDL原理](https://skytoby.github.io/2019/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder%E6%9C%BA%E5%88%B61-AIDL%E5%8E%9F%E7%90%86/)

- Stub类：Binder的实现类，服务端通过这个类来提供服务；
- Proxy类：服务器的本地代理，客户端通过这个类调用服务器的方法；
- asInterface()：客户端调用，将服务端的返回的Binder对象，转换成客户端所需要的AIDL接口类型对象。返回对象。
- asBinder()：返回代理Proxy的Binder对象；
- onTransact()：运行在服务端的线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。
- transact()：运行在客户端，当客户端发起远程请求的同时将当前线程挂起。之后调用服务端的onTransact()直到远程请求返回，当前线程才继续执行。


调用过程：客户端通过Proxy类调用Binder的transact()方法，将传入的参数通过Parcel类封装并在方法中传入，返回的数据也用Parcel封装，transact方法中会调用Binder的onTransact方法进行进程间通讯




# surface相关知识

Surface是图像数据的生产方，图形数据可以给到Surface，再将数据传递给消费防，比如surfaceFlinger，存入到FrameBuffer中，然后渲染出来。
  

# final修饰的地方

可以修饰类、方法、变量

# ams与activity通讯过程

  

# 如何获取cpu核数
```Java
// 获取 CPU 核数
Runtime.getRuntime().availableProcessors()
```

```C++
#include <unistd.h>

// 获取CPU核心数(包含禁用的)
long result = sysconf(_SC_NPROCESSORS_CONF);
// 获取可用的CPU核心数
long result = sysconf(_SC_NPROCESSORS_ONLN);

```
  

  

# singleinstance应用实例

  

# 实例创建过程

  

# flutter与java通讯

## MethodChannel 

### flutter调用Android方法

```dart
  Future<Null> getBetteryLevel() async {
    try {
      final int result = await platform.invokeMethod('getBetteryLevel');
      betteryText = "the bettery is $result";
    } on PlatformException catch (e) {
      betteryText = "the bettery get failed ${e.message}";
    }
    setState(() {});
  }
```

![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202311062104299.png)

### Android主动调用

![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202311062106316.png)

![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202311062107711.png)


## BasicMessageChannel

它是可以双端通信的，flutter端可以给Android发送消息，Android也可以给Flutter发送消息。

## EventChannel

只能是原生发送消息给Flutter端，例如监听手机电量变化，网络变化，传感器等。

## 参考链接

[Flutter与Android通讯](https://juejin.cn/post/7060136564810055710)



  

# 协程原理

  

# rgb565与rgb8888区别

  **jpeg是YUV的**

RGB565 是16位的，2个字节，5+6+5，第一字节的前5位是R，后三位+第二字节前三位是G，第二字节后5位是B。

RGB555 也是16位的，2个字节，RGB各5位，有1位未用。

RGB888 是24位的，3个字节。

  

# png。webp区别

- png：无损压缩；压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸
- webP：区分无损压缩和有损压缩，无损压缩的后的大小比png更小；另外还支持透明和动画；
  

# surfaceflinger渲染过程

是一个生产/消费的模式，surface是图形生产方，surfaceflinger是消耗方；

来自system进程，管理着帧缓冲区（Frame Buffer），

主要是分配图形缓冲区、合成图形缓冲区、管理VSYNC事件； 

每个应用和SurfaceFlinger之间会建立一个匿名共享内存ShareClient；在每个SharedClient中，最多可以创建31个SharedBufferStack，每一个SharedBufferStack对应一个Surface，即一个window。（其中包含了两个（小于4.1版本）或者三个（4.1及以上版本）缓冲区）

Android应用程序把经过测量、布局、绘制后的surface缓存数据、通过SurfaceFlinger把数据渲染到显示屏幕上，通过Android的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕。

1、应用层绘制到缓冲区。
2、SurfaceFlinger把缓冲区数据渲染到屏幕，其中使用了Android匿名共享内存SharedClient缓存需要显示的数据来达到目的。


# notify和notifyall的区别

- 锁池，线程想要一个已经被其他线程获取到锁权限的锁，就会进入锁池；
- 等待池：线程调用wait之后释放锁的权限，进入等待池；

notify是随机将一个等待池中的线程放入到锁池去竞争锁，notifyAll则是将等待池中所有线程放入锁池去竞争锁。

