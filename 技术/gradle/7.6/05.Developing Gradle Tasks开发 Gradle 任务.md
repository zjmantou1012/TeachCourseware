---
author: zjmantou
title: 05.Developing Gradle Tasks开发 Gradle 任务
time: 2024-07-17 周三
tags:
  - 技术
  - Gradle
---
# [创作任务](https://docs.gradle.org/7.6/userguide/more_about_tasks.html)

## 将参数传递给任务构造函数

通过 `@Inject` 

```groovy
abstract class CustomTask extends DefaultTask {
    final String message
    final int number

    @Inject
    CustomTask(String message, int number) {
        this.message = message
        this.number = number
    }
}

tasks.register('myTask', CustomTask, 'hello', 42)
```

## 向任务添加依赖项

### 使用名称 

引用另一个项目中的任务，在任务名称前加上其所属项目的路径作为前缀。

```groovy
project('project-a') {
    tasks.register('taskX')  {
        dependsOn ':project-b:taskY'
        doLast {
            println 'taskX'
        }
    }
}

project('project-b') {
    tasks.register('taskY') {
        doLast {
            println 'taskY'
        }
    }
}

Output of gradle -q taskX  gradle -q taskX 的输出
> gradle -q taskX
taskY
taskX
```


### 使用对象

使用 `TaskProvider` 对象定义依赖项，而不是使用任务名称 

```groovy
def taskX = tasks.register('taskX') {
    doLast {
        println 'taskX'
    }
}

def taskY = tasks.register('taskY') {
    doLast {
        println 'taskY'
    }
}

taskX.configure {
    dependsOn taskY
}
```

### 使用惰性块

惰性块应返回单个 Task 或 Task 对象的集合，然后将其视为任务的依赖项。 

```groovy
def taskX = tasks.register('taskX') {
    doLast {
        println 'taskX'
    }
}

// Using a Gradle Provider
taskX.configure {
    dependsOn(provider {
        tasks.findAll { task -> task.name.startsWith('lib') }
    })
}

tasks.register('lib1') {
    doLast {
        println('lib1')
    }
}

tasks.register('lib2') {
    doLast {
        println('lib2')
    }
}

tasks.register('notALib') {
    doLast {
        println('notALib')
    }
}

Output of **`gradle -q taskX`**  `gradle -q taskX` 的输出

> gradle -q taskX
lib1
lib2
taskX
```

## 排序任务

任务排序和任务依赖性之间的主要区别在于，排序规则不会影响将执行哪些任务，只会影响任务的执行顺序。 

### 应用场景

- 强制执行任务的顺序排序：例如“build”永远不会在“clean”之前运行。
- 在构建早期运行构建验证：例如在开始发布版本之前验证我拥有正确的凭据。
- 通过在长时间验证任务之前运行快速验证任务来更快地获得反馈：例如单元测试应在集成测试之前运行。
- 聚合特定类型所有任务结果的任务：例如测试报告任务结合了所有已执行测试任务的输出。

### mustRunAfter

指定 taskB 必须始终在 taskA 之后运行。 

```groovy
def taskX = tasks.register('taskX') {
    doLast {
        println 'taskX'
    }
}
def taskY = tasks.register('taskY') {
    doLast {
        println 'taskY'
    }
}
taskY.configure {
    mustRunAfter taskX
}

Output of gradle -q taskY taskX  gradle -q taskY taskX 的输出
> gradle -q taskY taskX
taskX
taskY
```

### shouldRunAfter

排序有帮助但不严格要求时，您应该使用“should run after”. 
	1. 使用该规则会引入订购周期（order lifecycle）
	2. 并行执行时，除了should之外其他的依赖项都满足，则无论should任务是否已运行，改任务都将执行。

**任务排序并不意味着任务执行** 

- 可以独立执行任务 A 和 B 。仅当两个任务都计划执行时，排序规则才有效。
- 当使用 --continue 运行时， B 可能会在 A 失败的情况下执行。

***如果“应该在之后运行”任务排序引入排序周期，则该任务排序将被忽略***

```groovy
def taskX = tasks.register('taskX') {
    doLast {
        println 'taskX'
    }
}
def taskY = tasks.register('taskY') {
    doLast {
        println 'taskY'
    }
}
def taskZ = tasks.register('taskZ') {
    doLast {
        println 'taskZ'
    }
}
taskX.configure { dependsOn(taskY) }
taskY.configure { dependsOn(taskZ) }
taskZ.configure { shouldRunAfter(taskX) }

Output of gradle -q taskX  gradle -q taskX 的输出
> gradle -q taskX
taskZ
taskY
taskX
```

## 向任务添加描述

您可以为您的任务添加描述。该描述在执行 gradle tasks 时显示。 

```groovy
tasks.register('copy', Copy) {
   description 'Copies the resource directory to the target directory.'
   from 'resources'
   into 'target'
   include('**/*.txt', '**/*.xml', '**/*.properties')
}
```

## 跳过任务

### Task.onlyIf 

仅当谓词评估为 true 时才会执行任务的操作。 

```groovy
def hello = tasks.register('hello') {
    doLast {
        println 'hello world'
    }
}

hello.configure {
    onlyIf("there is no property skipHello") { !project.hasProperty('skipHello') }
}

> gradle hello -PskipHello
> Task :hello SKIPPED

BUILD SUCCESSFUL in 0s
```

通过使用 --info 日志记录级别运行构建，可以找到跳过任务的原因。

```groovy
> gradle hello -PskipHello --info
...

> Task :hello SKIPPED
Skipping task ':hello' as task onlyIf 'there is no property skipHello' is false.
:hello (Thread[included builds,5,main]) completed. Took 0.018 secs.

BUILD SUCCESSFUL in 13s
```

### 使用 StopExecutionException 

如果跳过任务的逻辑无法用谓词表达，则可以使用 StopExecutionException。如果某个操作引发此异常，则将跳过此操作的进一步执行以及此任务的任何后续操作的执行。构建继续执行下一个任务。

```groovy
def compile = tasks.register('compile') {
    doLast {
        println 'We are doing the compile.'
    }
}

compile.configure {
    doFirst {
        // Here you would put arbitrary conditions in real life.
        if (true) {
            throw new StopExecutionException()
        }
    }
}
tasks.register('myTask') {
    dependsOn('compile')
    doLast {
        println 'I am not affected'
    }
}

> gradle -q myTask
I am not affected
```

### 启用和禁用任务

每个任务都有一个 enabled 标志，默认为 true 。将其设置为 false 可防止执行任何任务操作。禁用的任务将被标记为“已跳过”。

```groovy
def disableMe = tasks.register('disableMe') {
    doLast {
        println 'This should not be printed if the task is disabled.'
    }
}

disableMe.configure {
    enabled = false
}

> gradle disableMe
> Task :disableMe SKIPPED
```


### 任务超时 

每个任务都有一个 timeout 属性，可用于限制其执行时间。当任务达到超时时，其任务执行线程将被中断。该任务将被标记为失败。终结器任务仍将运行。如果使用 --continue ，则其他任务可以在其后继续运行。不响应中断的任务不能超时。 Gradle 的所有内置任务都会及时响应超时。

```groovy
tasks.register("hangingTask") {
    doLast {
        Thread.sleep(100000)
    }
    timeout = Duration.ofMillis(500)
}
```




