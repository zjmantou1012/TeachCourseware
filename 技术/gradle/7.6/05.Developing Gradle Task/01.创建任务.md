---
author: zjmantou
title: 05.Developing Gradle Tasks开发 Gradle 任务
time: 2024-07-17 周三
tags:
  - 技术
  - Gradle
---
# [创作任务](https://docs.gradle.org/7.6/userguide/more_about_tasks.html)

## 将参数传递给任务构造函数

通过 `@Inject` 

```groovy
abstract class CustomTask extends DefaultTask {
    final String message
    final int number

    @Inject
    CustomTask(String message, int number) {
        this.message = message
        this.number = number
    }
}

tasks.register('myTask', CustomTask, 'hello', 42)
```

## 向任务添加依赖项

### 使用名称 

引用另一个项目中的任务，在任务名称前加上其所属项目的路径作为前缀。

```groovy
project('project-a') {
    tasks.register('taskX')  {
        dependsOn ':project-b:taskY'
        doLast {
            println 'taskX'
        }
    }
}

project('project-b') {
    tasks.register('taskY') {
        doLast {
            println 'taskY'
        }
    }
}

Output of gradle -q taskX  gradle -q taskX 的输出
> gradle -q taskX
taskY
taskX
```


### 使用对象

使用 `TaskProvider` 对象定义依赖项，而不是使用任务名称 

```groovy
def taskX = tasks.register('taskX') {
    doLast {
        println 'taskX'
    }
}

def taskY = tasks.register('taskY') {
    doLast {
        println 'taskY'
    }
}

taskX.configure {
    dependsOn taskY
}
```

### 使用惰性块

惰性块应返回单个 Task 或 Task 对象的集合，然后将其视为任务的依赖项。 

```groovy
def taskX = tasks.register('taskX') {
    doLast {
        println 'taskX'
    }
}

// Using a Gradle Provider
taskX.configure {
    dependsOn(provider {
        tasks.findAll { task -> task.name.startsWith('lib') }
    })
}

tasks.register('lib1') {
    doLast {
        println('lib1')
    }
}

tasks.register('lib2') {
    doLast {
        println('lib2')
    }
}

tasks.register('notALib') {
    doLast {
        println('notALib')
    }
}

Output of **`gradle -q taskX`**  `gradle -q taskX` 的输出

> gradle -q taskX
lib1
lib2
taskX
```

## 排序任务

任务排序和任务依赖性之间的主要区别在于，排序规则不会影响将执行哪些任务，只会影响任务的执行顺序。 

### 应用场景

- 强制执行任务的顺序排序：例如“build”永远不会在“clean”之前运行。
- 在构建早期运行构建验证：例如在开始发布版本之前验证我拥有正确的凭据。
- 通过在长时间验证任务之前运行快速验证任务来更快地获得反馈：例如单元测试应在集成测试之前运行。
- 聚合特定类型所有任务结果的任务：例如测试报告任务结合了所有已执行测试任务的输出。

### mustRunAfter

指定 taskB 必须始终在 taskA 之后运行。 

```groovy
def taskX = tasks.register('taskX') {
    doLast {
        println 'taskX'
    }
}
def taskY = tasks.register('taskY') {
    doLast {
        println 'taskY'
    }
}
taskY.configure {
    mustRunAfter taskX
}

Output of gradle -q taskY taskX  gradle -q taskY taskX 的输出
> gradle -q taskY taskX
taskX
taskY
```

### shouldRunAfter

排序有帮助但不严格要求时，您应该使用“should run after”. 
	1. 使用该规则会引入订购周期（order lifecycle）
	2. 并行执行时，除了should之外其他的依赖项都满足，则无论should任务是否已运行，改任务都将执行。

**任务排序并不意味着任务执行** 

- 可以独立执行任务 A 和 B 。仅当两个任务都计划执行时，排序规则才有效。
- 当使用 --continue 运行时， B 可能会在 A 失败的情况下执行。

***如果“应该在之后运行”任务排序引入排序周期，则该任务排序将被忽略***

```groovy
def taskX = tasks.register('taskX') {
    doLast {
        println 'taskX'
    }
}
def taskY = tasks.register('taskY') {
    doLast {
        println 'taskY'
    }
}
def taskZ = tasks.register('taskZ') {
    doLast {
        println 'taskZ'
    }
}
taskX.configure { dependsOn(taskY) }
taskY.configure { dependsOn(taskZ) }
taskZ.configure { shouldRunAfter(taskX) }

Output of gradle -q taskX  gradle -q taskX 的输出
> gradle -q taskX
taskZ
taskY
taskX
```

## 向任务添加描述

您可以为您的任务添加描述。该描述在执行 gradle tasks 时显示。 

```groovy
tasks.register('copy', Copy) {
   description 'Copies the resource directory to the target directory.'
   from 'resources'
   into 'target'
   include('**/*.txt', '**/*.xml', '**/*.properties')
}
```

## 跳过任务

### Task.onlyIf 

仅当谓词评估为 true 时才会执行任务的操作。 

```groovy
def hello = tasks.register('hello') {
    doLast {
        println 'hello world'
    }
}

hello.configure {
    onlyIf("there is no property skipHello") { !project.hasProperty('skipHello') }
}

> gradle hello -PskipHello
> Task :hello SKIPPED

BUILD SUCCESSFUL in 0s
```

通过使用 --info 日志记录级别运行构建，可以找到跳过任务的原因。

```groovy
> gradle hello -PskipHello --info
...

> Task :hello SKIPPED
Skipping task ':hello' as task onlyIf 'there is no property skipHello' is false.
:hello (Thread[included builds,5,main]) completed. Took 0.018 secs.

BUILD SUCCESSFUL in 13s
```

### 使用 StopExecutionException 

如果跳过任务的逻辑无法用谓词表达，则可以使用 StopExecutionException。如果某个操作引发此异常，则将跳过此操作的进一步执行以及此任务的任何后续操作的执行。构建继续执行下一个任务。

```groovy
def compile = tasks.register('compile') {
    doLast {
        println 'We are doing the compile.'
    }
}

compile.configure {
    doFirst {
        // Here you would put arbitrary conditions in real life.
        if (true) {
            throw new StopExecutionException()
        }
    }
}
tasks.register('myTask') {
    dependsOn('compile')
    doLast {
        println 'I am not affected'
    }
}

> gradle -q myTask
I am not affected
```

### 启用和禁用任务

每个任务都有一个 enabled 标志，默认为 true 。将其设置为 false 可防止执行任何任务操作。禁用的任务将被标记为“已跳过”。

```groovy
def disableMe = tasks.register('disableMe') {
    doLast {
        println 'This should not be printed if the task is disabled.'
    }
}

disableMe.configure {
    enabled = false
}

> gradle disableMe
> Task :disableMe SKIPPED
```


### 任务超时 

每个任务都有一个 timeout 属性，可用于限制其执行时间。当任务达到超时时，其任务执行线程将被中断。该任务将被标记为失败。终结器任务仍将运行。如果使用 --continue ，则其他任务可以在其后继续运行。不响应中断的任务不能超时。 Gradle 的所有内置任务都会及时响应超时。

```groovy
tasks.register("hangingTask") {
    doLast {
        Thread.sleep(100000)
    }
    timeout = Duration.ofMillis(500)
}
```


## 增量构建

### 输入输出

![增量输入输出.png](https://docs.gradle.org/7.6/userguide/img/taskInputsOutputs.png) 

### 增量步骤 

1. 定义任务输入输出的类型化属性(getter)。
2. 为每个属性添加适当的注解([[增量构建属性类型注解||参考表]])。

### 支持的主要类别

- 简单的值
- 文件系统类型
- 依赖解析结果
- 嵌套值。

### 示例

```Java
buildSrc/src/main/java/org/example/ProcessTemplates.java
package org.example;

import java.util.HashMap;
import org.gradle.api.DefaultTask;
import org.gradle.api.file.ConfigurableFileCollection;
import org.gradle.api.file.DirectoryProperty;
import org.gradle.api.provider.Property;
import org.gradle.api.tasks.*;

public abstract class ProcessTemplates extends DefaultTask {

    @Input
    public abstract Property<TemplateEngineType> getTemplateEngine();

    @InputFiles
    public abstract ConfigurableFileCollection getSourceFiles();

    @Nested
    public abstract TemplateData getTemplateData();

    @OutputDirectory
    public abstract DirectoryProperty getOutputDir();

    @TaskAction
    public void processTemplates() {
        // ...
    }
}
buildSrc/src/main/java/org/example/TemplateData.java
package org.example;

import org.gradle.api.provider.MapProperty;
import org.gradle.api.provider.Property;
import org.gradle.api.tasks.Input;

public abstract class TemplateData {

    @Input
    public abstract Property<String> getName();

    @Input
    public abstract MapProperty<String, String> getVariables();
}

Output of `gradle processTemplates` (run again)  

> gradle processTemplates
> Task :processTemplates UP-TO-DATE

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 up-to-date
```

### 依赖性解析结果

依赖关系解析结果可以通过两种方式用作任务输入：
- 使用 ResolvedComponentResult 使用已解析元数据的图表。
- 使用 ResolvedArtifactResult 消耗已解析工件的平面集。

可以从 Configuration 的传入解析结果中延迟获取解析图并将其连接到 @Input 属性：

作为任务输入的解析图:

```Groovy
@Input
public abstract Property<ResolvedComponentResult> getRootComponent();

Configuration runtimeClasspath = configurations.getByName("runtimeClasspath");

task.getRootComponent().set(
    runtimeClasspath.getIncoming().getResolutionResult().getRootComponent()
);
```

可以从 Configuration 的传入工件中延迟获取已解析的工件集。鉴于 ResolvedArtifactResult 类型同时包含元数据和文件信息，因此仅在将实例连接到 @Input 属性之前才需要将实例转换为元数据：

将工件解析为任务输入:

```Java
@Input
public abstract ListProperty<ComponentArtifactIdentifier> getArtifactIds();

Configuration runtimeClasspath = configurations.getByName("runtimeClasspath");
Provider<Set<ResolvedArtifactResult>> artifacts = runtimeClasspath.getIncoming().getArtifacts().getResolvedArtifacts();

task.getArtifactIds().set(artifacts.map(new IdExtractor()));

static class IdExtractor
    implements Transformer<List<ComponentArtifactIdentifier>, Collection<ResolvedArtifactResult>> {
    @Override
    public List<ComponentArtifactIdentifier> transform(Collection<ResolvedArtifactResult> artifacts) {
        return artifacts.stream().map(ResolvedArtifactResult::getId).collect(Collectors.toList());
    }
}
```

### 运行时API

无权访问自定义任务类的源代码时，就无法添加任何注释，可以通过运行时 API访问

通过几个命名提供： 
- [TaskInputs](https://docs.gradle.org/7.6/javadoc/org/gradle/api/tasks/TaskInputs.html)类型：Task.getInput()
- [TaskOutputs](https://docs.gradle.org/7.6/javadoc/org/gradle/api/tasks/TaskOutputs.html)类型：Task.getOuntput()
- [TaskDestroyables](https://docs.gradle.org/7.6/javadoc/org/gradle/api/tasks/TaskDestroyables.html)类型：Task.getDestroyables()

无@Nested等效类型，需要通过拿到每个类型注解名来获取 

```Groovy
tasks.register('processTemplatesAdHoc') {
    inputs.property('engine', TemplateEngineType.FREEMARKER)
    inputs.files(fileTree('src/templates'))
        .withPropertyName('sourceFiles')
        .withPathSensitivity(PathSensitivity.RELATIVE)
    //TemplateData无法通过@Nested获取，必须要逐个获取属性类型
    inputs.property('templateData.name', 'docs')
    inputs.property('templateData.variables', [year: '2013'])
    outputs.dir(layout.buildDirectory.dir('genOutput2'))
        .withPropertyName('outputDir')

    doLast {
        // Process the templates here
    }
}
```

#### 颗粒度api

通过运行时 API 使用skipWhenEmpty()，当没有源文件时不执行此任务 

```groovy
tasks.register('processTemplatesAdHocSkipWhenEmpty') {
    // ...

    inputs.files(fileTree('src/templates') {
            include '**/*.fm'
        })
        .skipWhenEmpty()
        .withPropertyName('sourceFiles')
        .withPathSensitivity(PathSensitivity.RELATIVE)
        .ignoreEmptyDirectories()

    // ...
}

> gradle clean processTemplatesAdHocSkipWhenEmpty
> Task :processTemplatesAdHocSkipWhenEmpty NO-SOURCE

BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date
```

#### 自定义任务类型

假设 ProcessTemplates 任务还需要读取 src/headers/headers.txt （例如，因为它包含在其中一个源中）。希望 Gradle 了解此输入文件，以便每当此文件的内容发生更改时它都可以重新执行任务：

```Groovy
tasks.register('processTemplatesWithExtraInputs', ProcessTemplates) {
    // ...

    inputs.file('src/headers/headers.txt')
        .withPropertyName('headers')
        .withPathSensitivity(PathSensitivity.NONE)
}
```

### 副作用

#### 推断任务依赖关系

```groovy
tasks.register('packageFiles', Zip) {
    from processTemplates.map {it.outputs }
}

> gradle clean packageFiles
> Task :processTemplates
> Task :packageFiles

BUILD SUCCESSFUL in 0s
5 actionable tasks: 4 executed, 1 up-to-date
```

Gradle 会自动使 packageFiles 依赖于 processTemplates.

```Groovy
//通过任务参数推断依赖性

tasks.register('packageFiles2', Zip) {
    from processTemplates
}

> gradle clean packageFiles2
> Task :processTemplates
> Task :packageFiles2

BUILD SUCCESSFUL in 0s
5 actionable tasks: 4 executed, 1 up-to-date
```

#### 输入输出验证

- @InputFile - 验证属性是否具有值以及路径是否对应于存在的文件（而不是目录）
- @InputDirectory - 与 @InputFile 相同，但路径必须对应于目录。
- @OutputDirectory - 验证路径是否与文件不匹配，如果目录尚不存在，则创建该目录。

**通过@Optional禁用验证：告诉 Gradle 特定输入是可选的，因此如果相应的文件或目录不存在，构建不应失败。**

#### 持续构建

Gradle 知道任务依赖哪些文件，因此如果任务的任何输入发生变化，它可以自动再次运行任务。

通过在运行 Gradle 时激活连续构建（通过 `--continuous` 或 `-t` 选项），您将使 Gradle 进入一种状态，在该状态下，它会不断检查更改并在遇到请求时执行请求的任务。这样的变化。

#### 任务并行性

定义任务输入和输出的最后一个好处是，Gradle 可以使用此信息来决定在使用“--parallel”选项时如何运行任务。例如，Gradle 在选择下一个要运行的任务时将检查任务的输出，并避免并发执行写入同一输出目录的任务。同样，Gradle 将使用有关任务销毁哪些文件的信息（例如由 `Destroys` 注释指定），并避免在运行另一个消耗或创建这些相同文件的任务时运行删除一组文件的任务（反之亦然）。它还可以确定创建一组文件的任务已经运行，而使用这些文件的任务尚未运行，并且将避免运行在其间删除这些文件的任务。通过以这种方式提供任务输入和输出信息，Gradle 可以推断任务之间的创建/消耗/销毁关系，并可以确保任务执行不会违反这些关系。

### 进阶

#### 添加自己的缓存输入/输出方法

 Copy 任务的 from() 方法是如何工作的？它没有用 @InputFiles 注释，但传递给它的任何文件都被视为任务的正式输入。发生了什么？

将 sources() 方法添加到我们之前介绍的自定义 ProcessTemplates 类中：

```groovy
tasks.register('processTemplates', ProcessTemplates) {
    templateEngine = TemplateEngineType.FREEMARKER
    templateData.name = 'test'
    templateData.variables = [year: '2012']
    outputDir = file(layout.buildDirectory.dir('genOutput'))

    sources fileTree('src/templates')
}
```

```Java
public abstract class ProcessTemplates extends DefaultTask {
    // ...
    @SkipWhenEmpty
    @InputFiles
    @PathSensitive(PathSensitivity.NONE)
    public abstract ConfigurableFileCollection getSourceFiles();

    public void sources(FileCollection sourceFiles) {
        getSourceFiles().from(sourceFiles);
    }

    // ...
}
```

**只要在配置阶段将值和文件添加到正式任务输入和输出中，无论您在构建中的何处添加它们，它们都会被视为此类。** 

支持任务作为参数并将其输出视为输入，使用 `project.layout.files()` 方法:

```groovy
def copyTemplates = tasks.register('copyTemplates', Copy) {
    into file(layout.buildDirectory.dir('tmp'))
    from 'src/templates'
}

tasks.register('processTemplates2', ProcessTemplates) {
    // ...
    sources copyTemplates
}
```

```Java

//ProcessTemplates.java

public void sources(TaskProvider<?> inputTask) {
        getSourceFiles().from(getProject().getLayout().files(inputTask));
    }
```

```shell
> gradle processTemplates2
> Task :copyTemplates
> Task :processTemplates2

BUILD SUCCESSFUL in 0s
4 actionable tasks: 4 executed
```

#### [将 @OutputDirectory 链接到 @InputFiles](https://docs.gradle.org/7.6/userguide/more_about_tasks.html#sec:link_output_dir_to_input_files)

当您希望任务的 @OutputDirectory （类型为 File ）中的文件成为另一个任务的 @InputFiles 属性（类型为 FileCollection ）。由于两者类型不同，因此属性分配不起作用。

举个例子，假设您想要使用 Java 编译任务的输出（通过 destinationDir 属性）作为自定义任务的输入，该任务对一组包含 Java 字节码的文件进行检测。这个自定义任务，我们称之为 Instrument ，有一个 classFiles 属性，用 @InputFiles 注释。您最初可能会尝试像这样配置任务：

#### 禁用最新检查doNotTrackState

```groovy
tasks.register('alwaysInstrumentClasses', Instrument) {
    classFiles.from layout.files(tasks.named('compileJava'))
    destinationDir = file(layout.buildDirectory.dir('instrumented'))
    doNotTrackState("Instrumentation needs to re-run every time")
}

> gradle clean alwaysInstrumentClasses
> Task :compileJava
> Task :alwaysInstrumentClasses

BUILD SUCCESSFUL in 0s
4 actionable tasks: 1 executed, 3 up-to-date
```

#### 集成一个外部工具，该工具可以进行自己的最新检查

有时您想要集成 Git 或 Npm 等外部工具，它们都会进行自己的最新检查。在这种情况下，Gradle 也进行最新检查就没有多大意义。您可以通过在包装该工具的任务上使用 @[UntrackedTask](https://docs.gradle.org/7.6/javadoc/org/gradle/api/tasks/UntrackedTask.html) 注释来禁用 Gradle 的最新检查。或者，您可以使用运行时 API 方法 [Task.doNotTrackState()](https://docs.gradle.org/7.6/dsl/org.gradle.api.Task.html#org.gradle.api.Task:doNotTrackState(java.lang.String)) 。

Git 克隆任务：

```Java

//buildSrc/src/main/java/org/example/GitClone.java
@UntrackedTask(because = "Git tracks the state")             
public abstract class GitClone extends DefaultTask {

    @Input
    public abstract Property<String> getRemoteUri();

    @Input
    public abstract Property<String> getCommitId();

    @OutputDirectory
    public abstract DirectoryProperty getDestinationDir();

    @TaskAction
    public void gitClone() throws IOException {
        File destinationDir = getDestinationDir().get().getAsFile().getAbsoluteFile(); 
        String remoteUri = getRemoteUri().get();
        // Fetch origin or clone and checkout
        // ...
    }

}
```

```groovy
tasks.register("cloneGradleProfiler", GitClone) {
    destinationDir = layout.buildDirectory.dir("gradle-profiler")                      
    remoteUri = "https://github.com/gradle/gradle-profiler.git"
    commitId = "d6c18a21ca6c45fd8a9db321de4478948bdf801b"
}
```

1. 将任务声明为未跟踪。
2. 使用输出目录运行外部工具。
3. 添加任务并在 build.gradle 中配置输出目录。

#### [配置输入标准化](https://docs.gradle.org/7.6/userguide/more_about_tasks.html#sec:configure_input_normalization)

##### [属性文件规范化](https://docs.gradle.org/7.6/userguide/more_about_tasks.html#sec:property_file_normalization)

#### [提供自定义的最新逻辑](https://docs.gradle.org/7.6/userguide/more_about_tasks.html#sec:custom_up_to_date_logic)

## [任务规则](https://docs.gradle.org/7.6/userguide/more_about_tasks.html#sec:task_rules)

```groovy
tasks.addRule("Pattern: ping<ID>") { String taskName ->

    if (taskName.startsWith("ping")) {
        task(taskName) {
            doLast {
                println "Pinging: " + (taskName - 'ping')
            }
        }
    }
}

> gradle -q pingServer1
Pinging: Server1
```

依赖性 

```groovy
tasks.addRule("Pattern: ping<ID>") { String taskName ->

    if (taskName.startsWith("ping")) {
        task(taskName) {
            doLast {
                println "Pinging: " + (taskName - 'ping')
            }
        }
    }
}

tasks.register('groupPing') {
    dependsOn 'pingServer1', 'pingServer2'
}

> gradle -q groupPing
Pinging: Server1
Pinging: Server2
```

## [终结器任务](https://docs.gradle.org/7.6/userguide/more_about_tasks.html#sec:finalizer_tasks)

当计划运行最终任务时，终结器任务会自动添加到任务图中。

```groovy
def taskX = tasks.register('taskX') {
    doLast {
        println 'taskX'
    }
}
def taskY = tasks.register('taskY') {
    doLast {
        println 'taskY'
    }
}

taskX.configure { finalizedBy taskY }

> gradle -q taskX
taskX
taskY
```

**即使最终任务失败或者最终任务被认为是最新的，最终任务也会被执行。**

## [生命周期任务](https://docs.gradle.org/7.6/userguide/more_about_tasks.html#sec:lifecycle_tasks)

生命周期任务是指本身不工作的任务。他们通常没有任何任务操作。生命周期任务可以代表几个概念：

- 工作流程步骤（例如，使用 `check` 运行所有检查）
- 可构建的东西（例如，使用 `debug32MainExecutable` 为本机组件创建调试 32 位可执行文件)
- 执行许多相同逻辑任务的便捷任务（例如，使用 `compileAll` 运行所有编译任务）

