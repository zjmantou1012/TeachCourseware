---
author: zjmantou
title: 02.编写任务类型
time: 2024-07-20 周六
tags:
  - 技术
  - Gradle
---
# [开发自定义 Gradle 任务类型](https://docs.gradle.org/7.6/userguide/custom_tasks.html)

- 简单任务：闭包，适合一次性任务
- 增强型任务：Gradle插件

## 打包任务类 

可以在多个位置放置任务类的源代码：
- Build script：直接包含在构建脚本中，好处是人物类会自动编译并包含在构建脚本的类路径中，脚本外不可见。
- buildSrc：_rootProjectDir_/buildSrc/src/main/groovy或者rootProjectDir_/buildSrc/src/main/java 或者 rootProjectDir_/buildSrc/src/main/kotlin，对于构建使用的每个脚本可见，但是在构建之外不可见。
- Standalone project 独立项目：创建单独项目，生成并发布JAR

## 编写简单的任务

```groovy
//build.gradle

abstract class GreetingTask extends DefaultTask {
    @Input
    abstract Property<String> getGreeting()

    GreetingTask() {
        greeting.convention('hello from GreetingTask')
    }

    @TaskAction
    def greet() {
        println greeting.get()
    }
}

// Use the default greeting
tasks.register('hello', GreetingTask)

// Customize the greeting
tasks.register('greeting',GreetingTask) {
    greeting = 'greetings from GreetingTask'
}
> gradle -q hello greeting
hello from GreetingTask
greetings from GreetingTask

```


## 独立的项目

```groovy
//build.gradle

plugins {
    id 'groovy'
}

dependencies {
    implementation gradleApi()
}
```

```groovy
//src/main/groovy/org/gradle/GreetingTask.groovy

package org.gradle

import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction
import org.gradle.api.tasks.Input

class GreetingTask extends DefaultTask {

    @Input
    String greeting = 'hello from GreetingTask'

    @TaskAction
    def greet() {
        println greeting
    }
}
```

发布为jar文件

## 在另一个项目中使用任务类

将该类添加到构建脚本的类路径中。

```groovy
buildscript {
    repositories {
        maven {
            url = uri(repoLocation)
        }
    }
    dependencies {
        classpath 'org.gradle:task:1.0-SNAPSHOT'
    }
}

tasks.register('greeting', org.gradle.GreetingTask) {
    greeting = 'howdy!'
}
```

## 测试自定义的任务 

```groovy
//src/test/groovy/org/gradle/GreetingTaskTest.groovy

class GreetingTaskTest {
    @Test
    void canAddTaskToProject() {
        Project project = ProjectBuilder.builder().build()
        def task = project.task('greeting', type: GreetingTask)
        assertTrue(task instanceof GreetingTask)
    }
}
```

# 增量任务 

 IncrementalTask​​Inputs API在5.4以后已经删除，原因是无法查询单个输入文件属性的更改，而且不区分增量和非增量任务输入，因此任务本身需要确定更改源自何处。用InputChanges API替换。

### 实施增量任务 

InputChanges告诉Gradle该操作只想处理更改的输入，此外，该任务需要使用@Incremental或@SkipWhenEmpty声明至少一个增量文件输入属性。 

因为查询输入文件属性的增量更改，该属性就需要返回相同的实例。使用RegularFileProperty、DirectoryProperty 或 ConfigurableFileCollection。三个属性。 

InputChanges.getFileChanges()：返回FileChanges类型的Iterable：
- the [affected file](https://docs.gradle.org/7.6/javadoc/org/gradle/work/FileChange.html#getFile--) 受影响的文件
- the [change type](https://docs.gradle.org/7.6/javadoc/org/gradle/work/FileChange.html#getChangeType--) (`ADDED`, `REMOVED` or `MODIFIED`)
- the [normalized path](https://docs.gradle.org/7.6/javadoc/org/gradle/work/FileChange.html#getNormalizedPath--) of the changed file已更改文件的规范化路径
- the [file type](https://docs.gradle.org/7.6/javadoc/org/gradle/work/FileChange.html#getFileType--) of the changed file  
    已更改文件的文件类型

```GROOVY
//build.gradle

abstract class IncrementalReverseTask extends DefaultTask {
    @Incremental
    @PathSensitive(PathSensitivity.NAME_ONLY)
    @InputDirectory
    abstract DirectoryProperty getInputDir()

    @OutputDirectory
    abstract DirectoryProperty getOutputDir()

    @Input
    abstract Property<String> getInputProperty()

    @TaskAction
    void execute(InputChanges inputChanges) {
        println(inputChanges.incremental
            ? 'Executing incrementally'
            : 'Executing non-incrementally'
        )

        inputChanges.getFileChanges(inputDir).each { change ->
            if (change.fileType == FileType.DIRECTORY) return

            println "${change.changeType}: ${change.normalizedPath}"
            def targetFile = outputDir.file(change.normalizedPath).get().asFile
            if (change.changeType == ChangeType.REMOVED) {
                targetFile.delete()
            } else {
                targetFile.text = change.file.text.reverse()
            }
        }
    }
}
```

**如果由于某种原因任务以非增量方式执行，例如通过 `--rerun-tasks` 运行，则所有文件都将报告为 `ADDED` ，无论以前的状态如何。在这种情况下，Gradle 会自动删除之前的输出，因此增量任务只需要处理给定的文件。** 

### 哪些任务被认为是过时的 

- 没有先前执行的可用历史记录。
- 正在使用不同版本的 Gradle 进行构建。目前，Gradle 不使用不同版本的任务历史记录。
- 添加到任务的 upToDateWhen 标准返回 false 。
- 自上次执行以来，输入属性已更改。
- 自上次执行以来，非增量输入文件属性已更改。
- 自上次执行以来，一个或多个输出文件已更改。

### `taskInputProperty` 

设置属性为新值，则会重新执行 

```groovy
> gradle -q -PtaskInputProperty=changed incrementalReverse
Executing non-incrementally
ADDED: 1.txt
ADDED: 2.txt
ADDED: 3.txt
```

### [存储缓存任务的增量状态](https://docs.gradle.org/7.6/userguide/custom_tasks.html#sec:storing_incremental_task_state) 

如果状态文件是不可重定位的，则无法通过构建缓存共享它们。事实上，当从缓存加载任务时，必须清除任何此类状态文件，以防止过时的状态在下一次执行期间混淆工具。如果通过 task.localState.register() 声明此类陈旧文件或者使用 @LocalState 注释标记属性，Gradle 可以确保删除此类陈旧文件。 

## 声明和使用命令行选项  

`@Option` + setter 

自定义任务 UrlVerify 通过进行 HTTP 调用并检查响应代码来验证是否可以解析给定的 URL。要验证的 URL 可以通过属性 url 进行配置。该属性的 setter 方法用 @Option 注释。 

```Java

import org.gradle.api.tasks.options.Option;

public class UrlVerify extends DefaultTask {
    private String url;

    @Option(option = "url", description = "Configures the URL to be verified.")
    public void setUrl(String url) {
        this.url = url;
    }

    @Input
    public String getUrl() {
        return url;
    }

    @TaskAction
    public void verify() {
        getLogger().quiet("Verifying URL '{}'", url);

        // verify URL by making a HTTP call
    }
}
```

```groovy
tasks.register('verifyUrl', UrlVerify)

> gradle -q verifyUrl --url=http://www.google.com/
Verifying URL 'http://www.google.com/'
```

### 选项支持的数据类型 

- `boolean`, `Boolean`, `Property<Boolean>`
- `String`, `Property<String>`
- `Integer`, `Property<Integer>`
- `enum`, `Property<enum>`
- `List<String>`, `List<enum>`

### 记录选项的可用值 

借助注解 OptionValues 以编程方式记录此类选项的预期值。

```Java
import org.gradle.api.tasks.options.Option;
import org.gradle.api.tasks.options.OptionValues;

public class UrlProcess extends DefaultTask {
    private String url;
    private OutputType outputType;

    @Option(option = "url", description = "Configures the URL to be write to the output.")
    public void setUrl(String url) {
        this.url = url;
    }

    @Input
    public String getUrl() {
        return url;
    }

    @Option(option = "output-type", description = "Configures the output type.")
    public void setOutputType(OutputType outputType) {
        this.outputType = outputType;
    }

    @OptionValues("output-type")
    public List<OutputType> getAvailableOutputTypes() {
        return new ArrayList<OutputType>(Arrays.asList(OutputType.values()));
    }

    @Input
    public OutputType getOutputType() {
        return outputType;
    }

    @TaskAction
    public void process() {
        getLogger().quiet("Writing out the URL response from '{}' to '{}'", url, outputType);

        // retrieve content from URL and write to output
    }

    private static enum OutputType {
        CONSOLE, FILE
    }
}
```

### 列出选项的可用值 

通过`help`来 

```Groovy
> gradle -q help --task processUrl
Detailed task information for processUrl

Path
     :processUrl

Type
     UrlProcess (UrlProcess)

Options
     --output-type     Configures the output type.
                       Available values are:
                            CONSOLE
                            FILE

     --url     Configures the URL to be write to the output.

     --rerun     Causes the task to be re-run even if up-to-date.

Description
     -

Group
     -
```

### 局限性 

- 命令行选项只能通过注释为自定义任务声明。没有用于定义选项的程序等效项。
- 选项不能全局声明，例如在项目级别或作为插件的一部分。在命令行上分配选项时，需要明确说明暴露该选项的任务，例如即使 `check` 任务依赖于 `test` 任务， `gradle check --tests abc` 也不起作用。
- 如果您指定的任务选项名称与内置 Gradle 选项的名称冲突，请在调用任务之前使用 `--` 分隔符来引用该选项。有关详细信息，请参阅[消除任务选项与内置选项的歧义](https://docs.gradle.org/7.6/userguide/command_line_interface.html#sec:disambiguate_task_options_from_built_in_options)。

## Worker API 

允许在任务操作期间安全、并发地执行多个工作项目. 

还可以配置所需的隔离级别，以便可以在隔离的类加载器甚至隔离的进程中执行工作. 

### 如何使用 

实现Work单元以及Work单元的参数。 

单元的参数被定义为实现 WorkParameters 的接口或抽象类。参数类型必须是[managed type](https://docs.gradle.org/7.6/userguide/custom_gradle_types.html#managed_types). 

该实现是一个扩展 [WorkAction](https://docs.gradle.org/7.6/javadoc/org/gradle/workers/WorkAction.html) 的类。该类应该是抽象的，并且不应实现 `getParameters()` 方法。

更多work参数的信息：[Developing Custom Gradle Types](https://docs.gradle.org/7.6/userguide/custom_gradle_types.html#custom_gradle_types). 

*定义工作单元参数和实现：* 

```groovy
interface ReverseParameters extends WorkParameters {
    RegularFileProperty getFileToReverse()
    DirectoryProperty getDestinationDir()
}

// The implementation of a single unit of work.
abstract class ReverseFile implements WorkAction<ReverseParameters> {
    private final FileSystemOperations fileSystemOperations

    @Inject
    public ReverseFile(FileSystemOperations fileSystemOperations) {
        this.fileSystemOperations = fileSystemOperations
    }

    @Override
    void execute() {
        fileSystemOperations.copy {
            from parameters.fileToReverse
            into parameters.destinationDir
            filter { String line -> line.reverse() }
        }
    }
}

```

`WorkAction` 实现可以注入在工作执行期间提供功能的服务，例如上例中的 FileSystemOperations 服务[Service Injection](https://docs.gradle.org/7.6/userguide/custom_gradle_types.html#service_injection). 

提交工作单元，需要首先获取WorkerExecutor。为此，任务应该有一个用 `javax.inject.Inject` 注释的构造函数，该构造函数接受 WorkerExecutor 参数。 

```groovy
abstract class ReverseFiles extends SourceTask {
    private final WorkerExecutor workerExecutor

    @OutputDirectory
    abstract DirectoryProperty getOutputDir()

    // The WorkerExecutor will be injected by Gradle at runtime
    @Inject
    ReverseFiles(WorkerExecutor workerExecutor) {
        this.workerExecutor = workerExecutor
    }

    @TaskAction
    void reverseFiles() {
        // Create a WorkQueue to submit work items
        WorkQueue workQueue = workerExecutor.noIsolation()

        // Create and submit a unit of work for each file
        source.each { file ->
            workQueue.submit(ReverseFile.class) { ReverseParameters parameters ->
                parameters.fileToReverse = file
                parameters.destinationDir = outputDir
            }
        }
    }
}
```

可以使用 WorkQueue.await() 方法实现等待工作完成后再退出任务操作。 

```groovy
// Create a WorkQueue to submit work items
        WorkQueue workQueue = workerExecutor.noIsolation()

        // Create and submit a unit of work for each file
        source.each { file ->
            workQueue.submit(ReverseFile.class) { ReverseParameters parameters ->
                parameters.fileToReverse = file
                parameters.destinationDir = outputDir
            }
        }

        // Wait for all asynchronous work submitted to this queue to complete before continuing
        workQueue.await()
        logger.lifecycle("Created ${outputDir.get().asFile.listFiles().length} reversed files in ${projectLayout.projectDirectory.asFile.relativePath(outputDir.get().asFile)}")
```

### [Isolation Modes 隔离模式](https://docs.gradle.org/7.6/userguide/custom_tasks.html#isolation-modes) 

- [WorkerExecutor.noIsolation()](https://docs.gradle.org/7.6/javadoc/org/gradle/workers/WorkerExecutor.html#noIsolation--):这表明工作应该在具有最小隔离性的线程中运行。例如，它将共享与任务加载相同的类加载器。这是最快的隔离级别。
- [WorkerExecutor.classLoaderIsolation()](https://docs.gradle.org/7.6/javadoc/org/gradle/workers/WorkerExecutor.html#classLoaderIsolation-org.gradle.api.Action-)： 这表明工作应该在具有隔离类加载器的线程中运行。类加载器将具有来自加载工作单元实现类的类加载器的类路径，以及通过 ClassLoaderWorkerSpec.getClasspath() 添加的任何其他类路径条目。 
- [WorkerExecutor.processIsolation()](https://docs.gradle.org/7.6/javadoc/org/gradle/workers/WorkerExecutor.html#processIsolation-org.gradle.api.Action-) ： 这表明工作应该通过在单独的进程中执行工作来以最大程度的隔离来运行。该进程的类加载器将使用加载工作单元的类加载器中的类路径以及通过 ClassLoaderWorkerSpec.getClasspath() 添加的任何其他类路径条目。此外，该进程将是一个工作守护进程，它将保持活动状态，并且可以重用于未来可能具有相同要求的工作项。可以使用 ProcessWorkerSpec.forkOptions(org.gradle.api.Action) 使用与 Gradle JVM 不同的设置来配置此进程。

### 守护进程 

当使用 `processIsolation()` 时，gradle 将启动一个长期存在的 Worker Daemon 进程，可以在未来的工作项中重用。 

提交工作项以在工作进程守护程序中运行： 

```groovy
   // Create a WorkQueue with process isolation
        WorkQueue workQueue = workerExecutor.processIsolation() { ProcessWorkerSpec spec ->
            // Configure the options for the forked process
            forkOptions { JavaForkOptions options ->
                options.maxHeapSize = "512m"
                options.systemProperty "org.gradle.sample.showFileSize", "true"
            }
        }

        // Create and submit a unit of work for each file
        source.each { file ->
            workQueue.submit(ReverseFile.class) { ReverseParameters parameters ->
                parameters.fileToReverse = file
                parameters.destinationDir = outputDir
            }
        }
```

当提交 Worker Daemon 的工作单元时，Gradle 将首先查看是否已存在兼容的空闲守护进程。如果是，它会将工作单元发送到空闲守护进程，将其标记为忙碌。如果没有，它将启动一个新的守护进程。在评估兼容性时，Gradle 会考虑许多标准，所有这些标准都可以通过 ProcessWorkerSpec.forkOptions(org.gradle.api.Action) 进行控制。 

默认情况下，工作守护进程以 512MB 的最大堆启动。这可以通过调整工人分叉选项来改变。

|                            |                                                                                                                                                                                                      |
| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| executable 可执行文件      | 仅当守护进程使用相同的 java 可执行文件时，该守护进程才被视为兼容。                                                                                                                                   |
| classpath 类路径           | 如果守护进程的类路径包含所请求的所有类路径条目，则该守护进程被认为是兼容的。请注意，仅当类路径与请求的类路径完全匹配时，守护程序才被视为兼容。                                                       |
| heap settings              | 如果守护进程至少具有与请求相同的堆大小设置，则该守护进程被认为是兼容的。换句话说，具有比请求更高的堆设置的守护进程将被视为兼容。                                                                     |
| jvm arguments              | 如果守护进程已设置了请求的所有 jvm 参数，则该守护进程被认为是兼容的。请注意，如果守护进程具有超出请求的附加 jvm 参数（除了经过特殊处理的参数，如堆设置、断言、调试等），则该守护进程被认为是兼容的。 |
| system properties          | 如果守护程序已将请求的所有系统属性设置为相同的值，则该守护程序被视为兼容。请注意，如果守护程序具有超出所要求的其他系统属性，则该守护程序被视为兼容。                                                 |
| environment variables      | 如果守护进程已将请求的所有环境变量设置为相同的值，则该守护进程被认为是兼容的。请注意，如果守护程序除了所请求的变量之外还有更多环境变量，则认为该守护程序是兼容的。                                   |
| bootstrap classpath        | 如果守护进程包含所请求的所有引导类路径条目，则该守护进程被认为是兼容的。请注意，如果守护程序除了请求的条目之外还有更多引导类路径条目，则认为该守护进程是兼容的。                                     |
| debug                      | 仅当 debug 设置为与请求的值相同（true 或 false）时，守护程序才被视为兼容。                                                                                                                           |
| enable assertions 启用断言 | 仅当启用断言设置为与请求的值相同（true 或 false）时，守护程序才被视为兼容。                                                                                                                          |
| default character encoding | 仅当默认字符编码设置为与请求的值相同时，守护程序才被视为兼容。                                                                                                                                       |

## 取消和超时 

为了支持取消（例如，当用户使用 CTRL+C 停止构建时）和任务超时，自定义任务应该对其执行线程被中断做出反应。对于通过工作 API 提交的工作项也是如此。如果任务在 10 秒内没有响应中断，守护进程将关闭以释放系统资源。

## More 

将自定义任务类型打包到自定义 Gradle 插件中通常是一种好方法。该插件可以为任务类型提供有用的默认值和约定，并提供一种从构建脚本或其他插件使用任务类型的便捷方法。请参阅[开发自定义 Gradle 插件](https://docs.gradle.org/7.6/userguide/custom_plugins.html#custom_plugins)了解更多详细信息。 

Gradle 提供了许多在开发 Gradle 类型（包括任务）时很有帮助的功能。有关更多详细信息，请参阅开发自定义 Gradle 类型。