---
author: zjmantou
title: 并发
time: 2025-02-17 周一
tags:
  - 鸿蒙
  - 技术
---
# Actor并发模型

Actor并发模型每一个线程都是一个独立Actor，每个Actor有自己独立的内存，Actor之间通过消息传递机制触发对方Actor的行为，不同Actor之间不能直接访问对方的内存空间。

Actor并发模型对比内存共享并发模型的优势在于不同线程间内存隔离，不会产生不同线程竞争同一内存资源的问题。开发者不需要考虑对内存上锁导致的一系列功能、性能问题，提升了开发效率。

由于Actor并发模型线程之间不共享内存，需要通过线程间通信机制传输并发任务和任务结果。

![内存共享模型](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191241.09770119559676004339666238495197:50001231000000:2800:8CB0398572FAAD165E6C61141B472792BF7698E7DB605CF77639BCF027A1A42A.png?needInitFileName=true?needInitFileName=true)

# 异步并发

[Promise和async/await](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/async-concurrency-overview-V5) 

三种状态
- pending：进行中，创建后默认状态；
- fulfilled：已完成；
- rejected：已拒绝

Promise对象可以使用then处理fulfilled和rejected状态：

```ts
import { BusinessError } from '@kit.BasicServicesKit';

promise.then((result: number) => {
 console.info(`Random number is ${result}`);
}).catch((error: BusinessError) => {
 console.error(error.message);
});
```

> [!tip] 当Promise被reject且未通过catch方法来处理时，会触发unhandledrejection事件。可使用errorManager.on('error')接口监听该事件，以全局捕获未处理的Promise reject。

# 多线程并发

Worker 

# 线程间通信 

[官方文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/interthead-communication-V5) 

对于不同的数据对象，在ArkTS线程间通信的行为是有差异的。

- Worker：Actor并发模型标准的跨线程通信API，与Web Worker或者Node.js Worker的使用方式基本一致。
- TaskPool：提供了功能更强、并发编程更简易的任务池API。其中TaskPool涉及跨并发实例的对象传递行为与Worker一致，还是采用了标准的Structured Clone算法，并发通信的对象越大，耗时就越长。
## 线程间通信对象

### 普通对象

通过拷贝形式传递； 

两个线程的对象内容一致，但是指向各自线程的隔离内存区间，被分配在各自线程的虚拟机本地堆（LocalHeap）；

Object、Array、Map

![普通对象线程间通信](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.32463701159551395452707034620830:50001231000000:2800:1A4677F312AA386A792B5303239CA95B1B8038A430692FF740F4277947BC119D.png?needInitFileName=true?needInitFileName=true)


### ArrayBuffer对象

内部包含一块Native内存，ArrayBuffer的JS对象壳被分配在虚拟机本地堆（LocalHeap）。
需要经过序列划与反序列化拷贝传递，但是Native内存有两种传输方式：`拷贝`和`转移`。

![拷贝形式](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.82927038734362500123013009798183:50001231000000:2800:A4A68E034A3E404A2FB644FCC0190FFA6F38D44BC43EDA588C3A6FF28B6B6C41.png?needInitFileName=true?needInitFileName=true)


![转移形式](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.85716658638807189003157109127996:50001231000000:2800:5D209ACB8FA02C06C97732D7B6CE7DF47F3B77F4203E1708F1C56253C5E4A913.png?needInitFileName=true?needInitFileName=true)

应用场景：转移图片进行图片处理;

### SharedArrayBuffer对象

内部包含一块Native内存，其JS对象壳被分配在虚拟机本地堆（LocalHeap）。 

支持跨并发实例间共享，但是访问及修改需要采用Atomics类，防止数据竞争。

可以用于多个并发实例间的状态共享或者数据共享。

![SharedArrayBuffer对象通信](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.32097289692477713415967829467439:50001231000000:2800:5664ED3AB20B883638F06F7814D12A97145767D502DC3F87324C2B5F4AA84568.png?needInitFileName=true?needInitFileName=true)

```ts
import { taskpool } from '@kit.ArkTS';

@Concurrent
function transferAtomics(arg1: Int32Array) {
  console.info("wait begin::");
  // 使用Atomics进行操作
  let res = Atomics.wait(arg1, 0, 0, 3000);
  return res;
}

// 定义可共享对象
let sab: SharedArrayBuffer = new SharedArrayBuffer(20);
let int32 = new Int32Array(sab);
let task: taskpool.Task = new taskpool.Task(transferAtomics, int32);
taskpool.execute(task).then((res) => {
  console.info("this res is: " + res);
});
setTimeout(() => {
  Atomics.notify(int32, 0, 1);
}, 1000);
```

### Transferable对象（NativeBinding对象）

指的是一个JS对象，绑定了一个C++对象，且主体功能由C++提供，其JS对象壳被分配在虚拟机本地堆（LocalHeap）. 

跨线程传输时可以直接复用同一个C++对象，相比于JS对象的拷贝模式，传输效率较高。

#### 共享模式 

如果C++实现能够保证线程安全性，则这个NativeBinding对象的C++部分可以支持共享传输。此时，NativeBinding对象跨线程传输后，只需要重新创建JS壳，就可以桥接到相同的C++对象上。

![共享模式](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.63620466003732083195230847896847:50001231000000:2800:D6140B0179A07B68A058E1ADA688B4CF498AD2FD6A81A8218EED4FD7E35016B0.png?needInitFileName=true?needInitFileName=true)

例如：Context。

示例可参考[使用TaskPool进行频繁数据库操作](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/batch-database-operations-guide-V5#%E4%BD%BF%E7%94%A8taskpool%E8%BF%9B%E8%A1%8C%E9%A2%91%E7%B9%81%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C)。

#### 转移模式

如果C++实现包含了数据，且无法保证线程安全性，则这个NativeBinding对象的C++部分需要采用转移方式传输。

![转移模式](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250211191242.48435662525046737089225756160857:50001231000000:2800:21EAF6F2ED3337092FA2DB11E57FF392B39885048D08205A6020094D7AC7A0DD.png?needInitFileName=true?needInitFileName=true)

例如：[PixelMap对象](https://developer.huawei.com/consumer/cn/doc/harmonyos-references-V5/js-apis-image-V5#imagecreatepixelmap8)

### Sendable对象

在并发通信时支持通过**引用传递**来解决上述问题。 

Sendable对象为可共享的，其跨线程前后指向同一个JS对象，如果其包含了JS或者Native内容，均可以直接共享，如果底层是Native实现的，则需要考虑**线程安全性**。

- **[Sendable对象简介](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-sendable-V5)**      
- **[Sendable使用规则与约束](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/sendable-constraints-V5)**  
- **[异步锁](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-async-lock-introduction-V5)**  
- **[ASON解析与生成](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/ason-parsing-generation-V5)**  
- **[共享容器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-collections-introduction-V5)**  
- **[共享模块](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-sendable-module-V5)**  
- **[Sendable对象冻结](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/sendable-freeze-V5)**  
- **[Sendable使用场景](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/sendable-guide-V5)**

由于ArkTS语言支持异步操作，阻塞锁容易产生死锁问题，因此在ArkTS中**仅支持**异步锁（非阻塞式锁）。


[共享容器与原生API方法的行为差异对比](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-collections-introduction-V5#共享容器与原生api方法的行为差异对比) 

使用场景：
- 传输大数据
- 传递带方法的class实例对象，传输对象丢失方法，需使用引用传递。
## 线程间通信场景

- **[使用TaskPool执行独立的耗时任务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/independent-time-consuming-task-V5)**  
- **[使用TaskPool执行多个耗时任务](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/multi-time-consuming-tasks-V5)**  
- **[TaskPool任务与宿主线程通信](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/taskpool-communicates-with-mainthread-V5)**  
- **[Worker和宿主线程的即时消息通信](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/worker-communicates-with-mainthread-V5)**  
- **[Worker同步调用宿主线程的接口](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/worker-invoke-mainthread-interface-V5)**
