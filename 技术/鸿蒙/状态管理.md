---
author: zjmantou
title: 状态管理
time: 2025-02-17 周一
tags:
  - 鸿蒙
  - 技术
---

![状态管理](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250214112525.76833043958926988257496157451998:50001231000000:2800:419CCABB64BB73E67E0AEC58FDCA554FCC5E6B50A59FC989523E4D4FCD9580B9.png?needInitFileName=true?needInitFileName=true)

# V1版本

应用与组件同步：
- @StorageLink/@LocalStorageLink：双向同步
- @StorageProp/@LocalStorageProp：单向同步

组件状态：
- @State：单向/双向同步
- @Prop：单向同步
- @Link：双向同步
- @@PRovide/@Consume：多层组件同步
- @Observed：可观察嵌套场景，与@ObjectLink、@Prop一起使用
- @ObjectLink：可观察嵌套场景，双向同步,变量只读，不允许重新赋值；

应用状态：
- @AppStorage：应用程序特殊的单例LocalStorage对象，应用级数据库，和进程绑定；通过[@StorageProp](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-appstorage-V5#storageprop)和[@StorageLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-appstorage-V5#storagelink)装饰器可以和组件联动。
- 可以存储持久化数据[PersistentStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-persiststorage-V5)和环境变量[Environment](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-environment-V5)；
- LocalStorage：应用程序声明的应用状态的内存“数据库”，通常用于页面级的状态共享。通过[@LocalStorageProp](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-localstorage-V5#localstorageprop)和[@LocalStorageLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-localstorage-V5#localstoragelink)装饰器可以和UI联动。

[@Watch](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-watch-V5)用于监听状态变量的变化。

[$$运算符](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-two-way-sync-V5)：给内置组件提供TS变量的引用，使得TS变量和内置组件的内部状态保持同步。

## 组件冻结

freezeWhenInactive

使用场景：
- 页面路由：栈顶为active，非栈顶为inactive
- TabContent：当前显示的为active
- Navigation：当前显示的为active
- 组件复用：进入复用池的为inactive

## MVVM

[架构核心原则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-mvvm-V5#架构核心原则)

## 最佳实践

- 当子组件的属性不需要改变值时，考虑使用@ObjectLink代替，减少深拷贝；
- 不使用状态变量强行更新非状态变量关联组件
- 控制状态变量关联的组件数，共同的属性变更，可以抽到外部组件
- 合理控制对象类型状态变量关联的组件数量
- 避免在for、while等循环逻辑中频繁读取状态变量
- 建议使用临时变量替换状态变量

合理使用属性
- 将简单属性数组合并成对象数组，避免冗余刷新；因为数组只能观测数组顶层级的改变，如新增、修改、删除等。
- 将复杂的对象拆分成多个小对象
- 使用状态变量来对LazyForEach进行刷新
- 在ForEach中使用自定义组件搭配对象数组

# V2版本

为了增强状态管理V1版本的部分能力，例如深度观察、属性级更新等，ArkUI推出状态管理V2供开发者使用。

- @ObservedV2：配合@Trace使用
- @Trace：修饰@ObservedV2的类的属性
- @ComponentV2：组件使用
- @Local：组件内部状态，无法从外部初始化
- @Param：组件的输入，可以从外部传入初始化并同步
- @Once：仅初始化时同步一次，需与@Param一起使用
- @Event：修饰方法类型，作为组件输出，可通过此影响父组件的变量
- @Monitor：对状态变量深度监听
- @Provider/@Comsumer：跨组件层级双向同步
- @Computed：计算属性，在被计算的值变化的时候，只会计算一次。主要应用于解决UI多次重用该属性从而重复计算导致的性能问题。
- - [!!语法](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-new-binding-V5)：双向绑定语法糖。

## @Local

- 必须在组件内初始化
- 被@Local修饰的变量变化时能够刷新使用了该变量的组件
- 支持观测number、boolean、string、Object、class等基本类型以及Array、Set、Map、Date等内嵌类型。
- 支持null、undefined以及联合类型

### @State局限性

不能感知到值从外部初始化

### VS @State

|         | @State                   | @Local                   |
| :------ | :----------------------- | ------------------------ |
| 参数      | 无。                       | 无。                       |
| 从父组件初始化 | 可选。                      | 不允许外部初始化。                |
| 观察能力    | 能观测变量本身以及一层的成员属性，无法深度观测。 | 能观测变量本身，深度观测依赖@Trace装饰器。 |
| 数据传递    | 可以作为数据源和子组件中状态变量同步。      | 可以作为数据源和子组件中状态变量同步。      |

### 问题

[复杂类型常量重复赋值给状态变量触发刷新](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-new-local-V5#复杂类型常量重复赋值给状态变量触发刷新)

建议开发者在状态管理V2中谨慎使用animateTo接口。

# V1版本与V2版本优缺点

V1使用代理观察数据，创建一个状态变量时，同时也创建了一个数据代理观察者。观察者可感知代理变化，但无法感知实际数据变化：
- 不能独立于UI存在，同一个数据被多个View代理时，在其中一个View更改，不会通知其他View更新；
- 只能感知第一层变化；
- 存在冗余更新
- 限制多，不利于组件化；

V2的观察能力是数据本身，更改数据会触发相应的View更新，优点：
- 状态独立于UI，可触发一对多更新
- 支持嵌套层级
- 属性最小化更新
- 利于组件化

## 能力对比

[V1和V2能力对比](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-state-management-overview-V5#状态管理v1与v2能力对比)



# @Observed V1与V2区别

- V1无法对嵌套类对象属性变化进行直接观测，需要使用[@ObjectLink装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-observed-and-objectlink-V5)与自定义组件的方式实现观测。

## V2观测范围

- 嵌套类中@Trace属性
- 继承类中使用@Trace的属性
- 类中使用@Trace的静态属性
- 观察api变化：
	- Array：push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort
	- Date：setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds
	- Map：set, clear, delete
	- Set：add, clear, delete

## V2限制
- 非@Trace装饰的成员属性用在UI上无法触发UI刷新。
- @ObservedV2仅能装饰class，无法装饰自定义组件。
- @Trace不能用在没有被@ObservedV2装饰的class上。
- @Trace是class中属性的装饰器，不能用在struct中。
- @ObservedV2、@Trace不能与@Observed、@Track混合使用。
- 使用@ObservedV2与@Trace装饰的类不能和@State等V1的装饰器混合使用。
- 继承自@ObservedV2的类无法和@State等V1的装饰器混用，运行时报错。
- **@ObservedV2的类实例目前不支持使用JSON.stringify进行序列化。**

## V2使用场景

- 嵌套类
- 继承类
- Array、Map、Set、Date

# @ComponentV2与@Component混用

[混用文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-custom-component-mixed-scenarios-V5)。

