---
author: zjmantou
title: 状态管理
time: 2025-02-17 周一
tags:
  - 鸿蒙
  - 技术
---

![状态管理](https://alliance-communityfile-drcn.dbankcdn.com/FileServer/getFile/cmtyPub/011/111/111/0000000000011111111.20250214112525.76833043958926988257496157451998:50001231000000:2800:419CCABB64BB73E67E0AEC58FDCA554FCC5E6B50A59FC989523E4D4FCD9580B9.png?needInitFileName=true?needInitFileName=true)

# V1版本

应用与组件同步：
- @StorageLink/@LocalStorageLink：双向同步
- @StorageProp/@LocalStorageProp：单向同步

组件状态：
- @State：单向/双向同步
- @Prop：单向同步
- @Link：双向同步
- @@PRovide/@Consume：多层组件同步
- @Observed：可观察嵌套场景，与@ObjectLink、@Prop一起使用
- @ObjectLink：可观察嵌套场景，双向同步,变量只读，不允许重新赋值；

应用状态：
- @AppStorage：应用程序特殊的单例LocalStorage对象，应用级数据库，和进程绑定；通过[@StorageProp](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-appstorage-V5#storageprop)和[@StorageLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-appstorage-V5#storagelink)装饰器可以和组件联动。
- 可以存储持久化数据[PersistentStorage](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-persiststorage-V5)和环境变量[Environment](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-environment-V5)；
- LocalStorage：应用程序声明的应用状态的内存“数据库”，通常用于页面级的状态共享。通过[@LocalStorageProp](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-localstorage-V5#localstorageprop)和[@LocalStorageLink](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-localstorage-V5#localstoragelink)装饰器可以和UI联动。

[@Watch](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-watch-V5)用于监听状态变量的变化。

[$$运算符](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-two-way-sync-V5)：给内置组件提供TS变量的引用，使得TS变量和内置组件的内部状态保持同步。

## 组件冻结

freezeWhenInactive

使用场景：
- 页面路由：栈顶为active，非栈顶为inactive
- TabContent：当前显示的为active
- Navigation：当前显示的为active
- 组件复用：进入复用池的为inactive

## MVVM

[架构核心原则](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-mvvm-V5#架构核心原则)

## 最佳实践

- 当子组件的属性不需要改变值时，考虑使用@ObjectLink代替，减少深拷贝；
- 不使用状态变量强行更新非状态变量关联组件
- 控制状态变量关联的组件数，共同的属性变更，可以抽到外部组件
- 合理控制对象类型状态变量关联的组件数量
- 避免在for、while等循环逻辑中频繁读取状态变量
- 建议使用临时变量替换状态变量

合理使用属性
- 将简单属性数组合并成对象数组，避免冗余刷新；因为数组只能观测数组顶层级的改变，如新增、修改、删除等。
- 将复杂的对象拆分成多个小对象
- 使用状态变量来对LazyForEach进行刷新
- 在ForEach中使用自定义组件搭配对象数组

# V2版本

为了增强状态管理V1版本的部分能力，例如深度观察、属性级更新等，ArkUI推出状态管理V2供开发者使用。

- @ObservedV2：配合@Trace使用
- @Trace：修饰@ObservedV2的类的属性
- @ComponentV2：组件使用
- @Local：组件内部状态，无法从外部初始化
- @Param：组件的输入，可以从外部传入初始化并同步
- @Once：仅初始化时同步一次，需与@Param一起使用
- @Event：修饰方法类型，作为组件输出，可通过此影响父组件的变量
- @Monitor：对状态变量深度监听
- @Provider/@Comsumer：跨组件层级双向同步
- @Computed：计算属性，在被计算的值变化的时候，只会计算一次。主要应用于解决UI多次重用该属性从而重复计算导致的性能问题。
- - [!!语法](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-new-binding-V5)：双向绑定语法糖。

## @Local

- 必须在组件内初始化
- 被@Local修饰的变量变化时能够刷新使用了该变量的组件
- 支持观测number、boolean、string、Object、class等基本类型以及Array、Set、Map、Date等内嵌类型。
- 支持null、undefined以及联合类型

### @State局限性

不能感知到值从外部初始化

### VS @State

|         | @State                   | @Local                   |
| :------ | :----------------------- | ------------------------ |
| 参数      | 无。                       | 无。                       |
| 从父组件初始化 | 可选。                      | 不允许外部初始化。                |
| 观察能力    | 能观测变量本身以及一层的成员属性，无法深度观测。 | 能观测变量本身，深度观测依赖@Trace装饰器。 |
| 数据传递    | 可以作为数据源和子组件中状态变量同步。      | 可以作为数据源和子组件中状态变量同步。      |


## @Param @Once

相当于@Local，区别在于能够接受外部传入初始化

## @Event

由于@Param变量在本地无法更改，使用@Event配合毁掉方法可以实现更改数据源的变量，再通过@Local机制修改同步回@Param

## @Provider和@Consumer

[@Provider和@Consumer vs @Provide和@Consume能力对比](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-new-provider-and-consumer-V5#provider和consumer-vs-provide和consume能力对比)

- V2允许本地初始化，V1不允许
- V2支持function，V1不支持
- V2中alias是唯一匹配的key，V1优先alias，匹配不到就用属性名
- V2禁止从父组件初始化@Provider，V1允许
- V2默认开启支持重载，V1默认关闭

## @Monitor

监听变化

```ts
@Entry
@ComponentV2
struct Index {
  @Local message: string = "Hello World";
  @Local name: string = "Tom";
  @Local age: number = 24;
  @Monitor("message", "name")
  onStrChange(monitor: IMonitor) {
    monitor.dirty.forEach((path: string) => {
      console.log(`${path} changed from ${monitor.value(path)?.before} to ${monitor.value(path)?.now}`)
    })
  }
  build() {
    Column() {
      Button("change string")
        .onClick(() => {
          this.message += "!";
          this.name = "Jack";
      })
    }
  }
}
```

### V1中@Watcher局限性

无法实现对对象、数组中某一单个属性或数组项变化的监听，且无法获取变化之前的值。

### VS @Watcher

- 能够监听变量名和属性名，@Watcher只能回调方法名
- 能同时监听多个状态变量，@Watcher只能监听单个
- 深层，@Watcher一层
- 能获取变化前的值，@Watcher不能
- 监听对象为状态变量或者@Trace装饰的类成员属性，@Watcher只能前者
- 在@ComponetV2和@ObservedV2使用，@Watcher仅能在@Component中使用

## !!语法：双向绑定

用于初始化子组件的@Param和@Event，其中@Event方法名需要声明为"$" + @Param属性名
- 父组件使用了!!，则是双向同步
- 没有使用!!，单向同步

双向绑定的语法糖可以视为：
```ts
Star({ value: this.value, $value: (val: number) => { this.value = val }})
```

```ts
@Entry
@ComponentV2
struct Index {
  @Local value: number = 0;

  build() {
    Column() {
      Text(`${this.value}`)
      Button(`change value`).onClick(() => {
        this.value++;
      })
      Star({ value: this.value!! })
    }
  }
}



@ComponentV2
struct Star {
  @Param value: number = 0;
  @Event $value: (val: number) => void = (val: number) => {};

  build() {
    Column() {
      Text(`${this.value}`)
      Button(`change value `).onClick(() => {
        this.$value(10);
      })
    }
  }
}
```

## 组件冻结

```ts
@ComponentV2({ freezeWhenInactive: true })
```

## Repeat

### VS ForEach

- 优化了部分更新场景下的渲染性能
- 组件生产函数的索引index由框架侧来维护

### 使用限制

- 使用键值对作为表示，必须唯一
- virtualScroll场景必须在滚动类容器中使用
- virtualScroll开启后只允许创建一个组件
- 与自定义组件/@Builder函数混用时，必须将RepeatItem类型整体进行传参，组件才能监听到数据变化，如果只传递RepeatItem.item或RepeatItem.index，将会出现UI渲染异常。
- template模板目前只支持vertualScroll场景
- totalCount > array.length时，在父组件容器滚动过程中，应用需要保证列表即将滑动到数据源末尾时请求后续数据，直到数据源全部加载完成，否则列表滑动的过程中会出现滚动效果异常。
- 在滚动容器组件内只能包含一个Repeat
- virtualScroll场景不支持V1装饰器

### 组件生成和复用规则

- non-virtualScroll规则：首次渲染时全部创建，在数据更新时会对原组件进行复用。
- 首次渲染只生成当前需要的组件，在滑动和数据更新时会缓存下屏的节点，在需要生成新的组件时，对缓存里的组件进行复用。

## @makeObserved接口

- 与@Sendable一起使用，使得并发后的数据可以做状态更新
- 和collections.Array/Set/Map使用
- JSON.parse返回值
- 和V2装饰器配合使用
- 在@Component中使用

## MVVM

[V2-MVVM](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-mvvm-v2-V5)

## 混用场景

[自定义组件混用场景指导](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-custom-component-mixed-scenarios-V5)

## 问题

[复杂类型常量重复赋值给状态变量触发刷新](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-new-local-V5#复杂类型常量重复赋值给状态变量触发刷新)

建议开发者在状态管理V2中谨慎使用animateTo接口。

# V1版本与V2版本优缺点

V1使用代理观察数据，创建一个状态变量时，同时也创建了一个数据代理观察者。观察者可感知代理变化，但无法感知实际数据变化：
- 不能独立于UI存在，同一个数据被多个View代理时，在其中一个View更改，不会通知其他View更新；
- 只能感知第一层变化；
- 存在冗余更新
- 限制多，不利于组件化；

V2的观察能力是数据本身，更改数据会触发相应的View更新，优点：
- 状态独立于UI，可触发一对多更新
- 支持嵌套层级
- 属性最小化更新
- 利于组件化

## 能力对比

[V1和V2能力对比](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-state-management-overview-V5#状态管理v1与v2能力对比)



# @Observed V1与V2区别

- V1无法对嵌套类对象属性变化进行直接观测，需要使用[@ObjectLink装饰器](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-observed-and-objectlink-V5)与自定义组件的方式实现观测。

## V2观测范围

- 嵌套类中@Trace属性
- 继承类中使用@Trace的属性
- 类中使用@Trace的静态属性
- 观察api变化：
	- Array：push、pop、shift、unshift、splice、copyWithin、fill、reverse、sort
	- Date：setFullYear, setMonth, setDate, setHours, setMinutes, setSeconds, setMilliseconds, setTime, setUTCFullYear, setUTCMonth, setUTCDate, setUTCHours, setUTCMinutes, setUTCSeconds, setUTCMilliseconds
	- Map：set, clear, delete
	- Set：add, clear, delete

## V2限制
- 非@Trace装饰的成员属性用在UI上无法触发UI刷新。
- @ObservedV2仅能装饰class，无法装饰自定义组件。
- @Trace不能用在没有被@ObservedV2装饰的class上。
- @Trace是class中属性的装饰器，不能用在struct中。
- @ObservedV2、@Trace不能与@Observed、@Track混合使用。
- 使用@ObservedV2与@Trace装饰的类不能和@State等V1的装饰器混合使用。
- 继承自@ObservedV2的类无法和@State等V1的装饰器混用，运行时报错。
- **@ObservedV2的类实例目前不支持使用JSON.stringify进行序列化。**

## V2使用场景

- 嵌套类
- 继承类
- Array、Map、Set、Date

# @ComponentV2与@Component混用

[混用文档](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-custom-component-mixed-scenarios-V5)。

