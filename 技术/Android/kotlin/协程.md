---
author: zjmantou
title: 协程
time: 2024-02-10 周六
tags:
  - Android
  - Kotlin
  - 协程
---
# 官方定义 

轻量级线程 

## 与线程的区别 

从系统角度看：
- 像通过Thread.sleep，Thread.wait这种方式是会阻塞线程，直到被唤醒才会继续往下执行，这个过程是通过系统来调度的，会释放CPU资源让其他线程占用。 
- 协程的刮起（suspend）是不会释放CPU资源，也就是说协程的挂起更像是程序主动发起，不再交由系统调度。 

**当协程挂起时会释放底层的线程去干其他事情，这样能够最大限度的利用线程做更多的事情，提高效率。** 

### 例子 

```kotlin
val startTime = System.currentTimeMillis()
repeat(100000){
    thread {
        Thread.sleep(100)
    }
}
Log.e("TAG","start 10w thread cost ${System.currentTimeMillis() - startTime}")

2023-06-21 23:17:17.273 16989-16989/com.lay.nowinandroid E/TAG: start 10w thread cost 27279

```

```kotlin
val startTime = System.currentTimeMillis()
repeat(100000){
    GlobalScope.launch {
        delay(1000)
    }
}
Log.e("TAG","start 10w coroutines cost ${System.currentTimeMillis() - startTime}")

2023-06-21 23:18:53.189 26327-26327/com.lay.nowinandroid E/TAG: start 10w coroutines cost 1088

```

上面的耗时对比能够看到，协程挂起时，确实确实能够提高效率。 

协程不会阻塞线程，而线程则是会阻塞线程。 

通过协程作用域，实现对线程的阻塞。 

# 协程作用域 (CoroutineScope)

协程作用域其实就是提供协程创建的环境，所有的协程都必须要在协程作用域中创建，而且每个协程作用域都会有自己的上下文，每个协程也有自己的上下文。 

CoroutineScope主要有以下几种：
- GlobalScope：即全局协程作用域，在这个范围内启动的协程可以一直运行直到应用停止运行。GlobalScope 本身不会阻塞当前线程，且启动的协程相当于守护线程，不会阻止 JVM 结束运行。
- runBlocking。一个顶层函数，和 GlobalScope 不一样，它会阻塞当前线程直到其内部所有相同作用域的协程执行结束。
- 自定义 CoroutineScope。可用于实现主动控制协程的生命周期范围，对于 Android 开发来说最大意义之一就是可以在 Activity、Fragment、ViewModel 等具有生命周期的对象中按需取消所有协程任务，从而确保生命周期安全，避免内存泄露。

## GlobalScope

```kotlin
fun main() {
    log("start")
    GlobalScope.launch {
        launch {
            delay(400)
            log("launch A")
        }
        launch {
            delay(300)
            log("launch B")
        }
        log("GlobalScope")
    }
    log("end")
    Thread.sleep(500)
}


[main] start
[main] end
[DefaultDispatcher-worker-1] GlobalScope
[DefaultDispatcher-worker-3] launch B
[DefaultDispatcher-worker-3] launch A

```

`GlobalScope.launch` 会创建一个顶级协程，尽管它很轻量级，但在运行时还是会消耗一些内存资源，且可以一直运行直到整个应用程序停止（只要任务还未结束），这可能会导致内存泄露，所以在日常开发中应该谨慎使用 GlobalScope。 

## runBlocking 

```kotlin
fun main() {
    log("start")
    runBlocking {
        launch {
            repeat(3) {
                delay(100)
                log("launchA - $it")
            }
        }
        launch {
            repeat(3) {
                delay(100)
                log("launchB - $it")
            }
        }
        GlobalScope.launch {
            repeat(3) {
                delay(120)
                log("GlobalScope - $it")
            }
        }
    }
    log("end")
}


[main] start
[main] launchA - 0
[main] launchB - 0
[DefaultDispatcher-worker-1] GlobalScope - 0
[main] launchA - 1
[main] launchB - 1
[DefaultDispatcher-worker-1] GlobalScope - 1
[main] launchA - 2
[main] launchB - 2
[main] end

```

**runBlocking 本身带有阻塞线程的意味，但其内部运行的协程又是非阻塞的，读者需要明白这两者的区别**

## coroutineScope

coroutineScope 函数用于创建一个独立的协程作用域，直到所有启动的协程都完成后才结束自身。 
与runBlocking主要区别在于：runBlocking会阻塞当前线程，而coroutineScope不会，而是会挂起并释放底层线程以供其它协程使用。

```kotlin
fun main() = runBlocking {
    launch {
        delay(100)
        log("Task from runBlocking")
    }
    coroutineScope {
        launch {
            delay(500)
            log("Task from nested launch")
        }
        delay(50)
        log("Task from coroutine scope")
    }
    log("Coroutine scope is over")
}

[main] Task from coroutine scope
[main] Task from runBlocking
[main] Task from nested launch
[main] Coroutine scope is over

```

## supervisorScope

`supervisorScope` 函数用于创建一个使用了 SupervisorJob 的 coroutineScope，该作用域的特点就是抛出的异常不会连锁取消同级协程和父协程. 

```kotlin

fun main() = runBlocking {
    launch {
        delay(100)
        log("Task from runBlocking")
    }
    supervisorScope {
        launch {
            delay(500)
            log("Task throw Exception")
            throw Exception("failed")
        }
        launch {
            delay(600)
            log("Task from nested launch")
        }
    }
    log("Coroutine scope is over")
}


[main] Task from runBlocking
[main] Task throw Exception
[main] Task from nested launch
[main] Coroutine scope is over

```

## 自定义 CoroutineScope

假设我们在 Activity 中先后启动了多个协程用于执行异步耗时操作，那么当 Activity 退出时，必须取消所有协程以避免内存泄漏。我们可以通过保留每一个 Job 引用然后在 `onDestroy`方法里来手动取消，但这种方式相当来说会比较繁琐和低效。kotlinx.coroutines 提供了 CoroutineScope 来管理多个协程的生命周期

我们可以通过创建与 Activity 生命周期相关联的协程作用域来管理协程的生命周期。CoroutineScope 的实例可以通过 `CoroutineScope()` 或 `MainScope()` 的工厂函数来构建。前者创建通用作用域，后者创建 UI 应用程序的作用域并使用 Dispatchers.Main 作为默认的调度器。 

```kotlin

class Activity {

    private val mainScope = MainScope()

    fun onCreate() {
        mainScope.launch {
            repeat(5) {
                delay(1000L * it)
            }
        }
    }

    fun onDestroy() {
        mainScope.cancel()
    }

}

```

或者，我们可以通过委托模式来让 Activity 实现 CoroutineScope 接口，从而可以在 Activity 内直接启动协程而不必显示地指定它们的上下文，并且在 `onDestroy()`中自动取消所有协程 

```kotlin
class Activity : CoroutineScope by CoroutineScope(Dispatchers.Default) {

    fun onCreate() {
        launch {
            repeat(5) {
                delay(200L * it)
                log(it)
            }
        }
        log("Activity Created")
    }

    fun onDestroy() {
        cancel()
        log("Activity Destroyed")
    }

}

fun main() = runBlocking {
    val activity = Activity()
    activity.onCreate()
    delay(1000)
    activity.onDestroy()
    delay(1000)
}

从输出结果可以看出，当回调了`onDestroy()`方法后协程就不会再输出日志了

[main] Activity Created
[DefaultDispatcher-worker-1] 0
[DefaultDispatcher-worker-1] 1
[DefaultDispatcher-worker-1] 2
[main] Activity Destroyed

```

已取消的作用域无法再创建协程。因此，仅当控制其生命周期的类被销毁时，才应调用 `scope.cancel()`。例如，使用 `viewModelScope` 时， ViewModel 会在自身的 `onCleared()` 方法中自动取消作用域

# CoroutineBuilder 

## launch

用于在不阻塞当前线程的情况下启动一个协程，并返回对该协程任务的引用，即 Job 对象。

包含三个参数：
1. context。用于指定协程的上下文
2. start。用于指定协程的启动方式，默认值为 `CoroutineStart.DEFAULT`，即协程会在声明的同时就立即进入等待调度的状态，即可以立即执行的状态。可以通过将其设置为`CoroutineStart.LAZY`来实现延迟启动，即懒加载
3. block。用于传递协程的执行体，即希望交由协程执行的任务

## Job

Job 是协程的句柄。使用 launch 或 async 创建的每个协程都会返回一个 Job 实例，该实例唯一标识协程并管理其生命周期。Job 是一个接口类型，这里列举 Job 几个比较有用的属性和函数. 

```Kotlin
//当 Job 处于活动状态时为 true
//如果 Job 未被取消或没有失败，则均处于 active 状态
public val isActive: Boolean

//当 Job 正常结束或者由于异常结束，均返回 true
public val isCompleted: Boolean

//当 Job 被主动取消或者由于异常结束，均返回 true
public val isCancelled: Boolean

//启动 Job
//如果此调用的确启动了 Job，则返回 true
//如果 Job 调用前就已处于 started 或者是 completed 状态，则返回 false 
public fun start(): Boolean

//用于取消 Job，可同时通过传入 Exception 来标明取消原因
public fun cancel(cause: CancellationException? = null)

//阻塞等待直到此 Job 结束运行
public suspend fun join()

//当 Job 结束运行时（不管由于什么原因）回调此方法，可用于接收可能存在的运行异常
public fun invokeOnCompletion(handler: CompletionHandler): DisposableHandle

```

Job 具有以下几种状态值，每种状态对应的属性值各不相同 

| State                            | isActive | isCompleted | isCancelled |
| -------------------------------- |:--------:|:-----------:|:-----------:|
| _New_ (optional initial state)   |  false   |    false    |    false    |
| _Active_ (default initial state) |   true   |    false    |    false    |
| Completing (transient state)     |   true   |    false    |    false    |
| Cancelling (transient state)     |  false   |    false    |    true     |
| Cancelled (final state)          |  false   |    true     |    true     |
| Completed (final state)          |  false   |    true     |    false    |

## async

和 launch 的区别主要就在于：async 可以返回协程的执行结果，而 launch 不行. 



# 协程上下文（Coroutine Context）

## Job

协程中的 Job 是其上下文 CoroutineContext 中的一部分，可以通过 coroutineContext[Job] 表达式从上下文中获取到，我们可以通过控制 Job 来控制 CoroutineScope 的生命周期. 

```kotlin

val job = Job()

val scope = CoroutineScope(job + Dispatchers.IO)

fun main(): Unit = runBlocking {
    log("job is $job")
    val job = scope.launch {
        try {
            delay(3000)
        } catch (e: CancellationException) {
            log("job is cancelled")
            throw e
        }
        log("end")
    }
    delay(1000)
    log("scope job is ${scope.coroutineContext[Job]}")
    scope.coroutineContext[Job]?.cancel()
}


[main] job is JobImpl{Active}@759ebb3d
[main] scope job is JobImpl{Active}@759ebb3d
[DefaultDispatcher-worker-1] job is cancelled

```

## CoroutineDispatcher(协程调度器)

用于指定执行协程的目标载体，即 运行于哪个线程。 

在 Kotlin 中，所有协程都必须在 CoroutineDispatcher 中运行，即使它们在主线程上运行也是如此。 

协程可以自行暂停，而 CoroutineDispatcher 负责将其恢复。 

Kotlin 协程库提供了四个 Dispatcher 用于指定在哪一类线程中执行协程：
- Dispatchers.Default。默认调度器，适合用于执行占用大量 CPU 资源的任务。例如：对列表排序和解析 JSON
- Dispatchers.IO。适合用于执行磁盘或网络 I/O 的任务。例如：使用 Room 组件、读写磁盘文件，执行网络请求
- Dispatchers.Unconfined。对执行协程的线程不做限制，可以直接在当前调度器所在线程上执行
- Dispatchers.Main。使用此调度程序可用于在 Android 主线程上运行协程，只能用于与界面交互和执行快速工作，例如：更新 UI、调用 `LiveData.setValue`。

## withContext

由于withContext()支持在不引入回调的情况下控制任何代码的执行线程池，因此你可以将其应用于非常小的函数，例如从数据库中读取数据或执行网络请求。一种不错的做法是使用 withContext() 来确保每个函数都是主线程安全的，这意味着，你可以从主线程调用每个函数。这样，调用方就从不需要考虑应该使用哪个线程来执行函数了。 

与基于回调的等效实现相比，withContext() 不会增加额外的开销。此外，在某些情况下，还可以优化 withContext() 调用，使其超越基于回调的等效实现。例如，如果某个函数需要先后调用十次网络请求，你可以在最外层调用 withContext() 让协程只切换一次线程，这样即使每个网络请求内部均会使用 withContext()，它也会留在同一调度程序上，从而避免频率切换线程。此外，协程还优化了 Dispatchers.Default 与 Dispatchers.IO 之间的切换，以尽可能避免线程切换。 

## CoroutineName 

CoroutineName 用于为协程指定一个名字，方便调试和定位问题

```kotlin

fun main() = runBlocking<Unit>(CoroutineName("RunBlocking")) {
    log("start")
    launch(CoroutineName("MainCoroutine")) {
        launch(CoroutineName("Coroutine#A")) {
            delay(400)
            log("launch A")
        }
        launch(CoroutineName("Coroutine#B")) {
            delay(300)
            log("launch B")
        }
    }
}

```

## CoroutineExceptionHandler

## 组合上下文元素

有时我们需要为协程上下文定义多个元素，此时就可以用 + 运算符。例如，我们可以同时为协程指定 Dispatcher 和 CoroutineName. 

```kotlin
fun main() = runBlocking<Unit> {
    launch(Dispatchers.Default + CoroutineName("test")) {
        log("Hello World")
    }
}

```



# 协程的取消

## 协程一定能被取消吗？

**在所有被挂起的协程才能被取消。**  

当协程在执行**CPU密集型任务**时，是没有检查取消的（因为没有挂起的这个契机，除非加上delay等挂起函数），所以协程便不能被取消。 

比如下面例子： 

```kotlin
fun test2() = runBlocking {
    val job = launch {
        for (i in 0..100) {
            Log.e("TAG", "now is $i")
        }
    }
    delay(5)
    Log.e("TAG", "准备取消......")
    job.cancelAndJoin()
    Log.e("TAG", "结束任务")
}
一直在计算密集任务，但是没有被挂起，所以无法取消.
```

## CPU密集型任务如何取消？

### 1. 定期使用挂起函数检查协程是否被取消，常见如yield函数 

```kotlin
fun test2() = runBlocking {
    val job = launch{
        for (i in 0..100) {
            yield()
            Log.e("TAG", "now is $i $isActive")
        }
    }
    delay(5)
    Log.e("TAG", "准备取消......")
    job.cancel()
    Log.e("TAG", "结束任务")
}

```

### 2. 使用isActive或者ensureActive判断当前协程是否活跃 

当协程被取消之后，isActive就会变为false，此时进入到Cancelling取消中的状态，直到协程取消进入到Cancelled状态。

```kotlin
fun test2() = runBlocking {
    val job = launch(Dispatchers.Default) {
        for (i in 0..1000) {
            if (isActive) {
                Log.e("TAG", "now is $i")
            } else {
                break
            }
        }
    }
    delay(5)
    Log.e("TAG", "准备取消......")
    job.cancelAndJoin()
    Log.e("TAG", "结束任务")
}

```


# 总结

1. 协程是一个轻量级线程框架；
2. 是非阻塞式的，可以通过挂起释放底层线程去做其他事情，从而提高线程的利用率；
3. 协程需要在协程作用域中工作，协程作用域包含一个协程上下文，上下文中包含：
	1. Job
	2. CoroutineDispatcher调度器：协程代码块必须在指定的调度器中执行。
	3. CoroutineName：协程名字
	4. CoroutineExceptionHandler：处理异常

整体流程：
suspend修饰的协程代码块在协程作用域中首先以非阻塞式的挂起，然后通过指定的调度器去指定的线程执行，执行完毕后恢复协程继续执行下面代码。



# 参考链接

[一文快速入门 Kotlin 协程](https://juejin.cn/post/6908271959381901325#heading-4)

[github.com/Kotlin/Kotl…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FKotlin%2FKotlinx.coroutines%2Fblob%2Fmaster%2Fcoroutines-guide.md "https://github.com/Kotlin/Kotlinx.coroutines/blob/master/coroutines-guide.md")
[developer.android.google.cn/kotlin/coro…](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fkotlin%2Fcoroutines "https://developer.android.google.cn/kotlin/coroutines")
[juejin.cn/post/684490…](https://juejin.cn/post/6844904118180380680 "https://juejin.cn/post/6844904118180380680")
[juejin.cn/post/688825…](https://juejin.cn/post/6888259219008126983 "https://juejin.cn/post/6888259219008126983")
