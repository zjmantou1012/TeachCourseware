
# 为什么会调用两次onMeasure

方法都是在ViewRootImpl#performMeasure方法中：
- 第一次是measureHierarchy方法：为了确定window的尺寸；
- 第二次是performMeasure方法：确定各个控件的尺寸。

[进入Activity时，为何页面布局内View#onMeasure会被调用两次？](https://blog.csdn.net/qq_26287435/article/details/123274342)

# ConstraintLayout源码

[从源码角度理解ConstraintLayout#onMeasure对child的measure调用次数](https://juejin.cn/post/7072307652537090079)

```
1、ConstraintLayout中：
①持有ConstraintWidgetContainer对象mLayoutWidget，绘制是交给ConstraintWidgetContainer来处理的。
②持有Measurer对象mMeasurer，ConstraintLayout中实现了Measurer接口，所有的绘制最终都会调用到ConstraintLayout#Measurer#measure中。

2、ConstraintWidgetContainer中：
①持有多个ConstraintWidget对象，ConstraintLayout的一个child对应一个ConstraintWidget对象。ConstraintWidget对象中也会持有child对象。
②持有BasicMeasure对象mBasicMeasureSolver，BasicMeasure是测量流程的核心类。
③持有DependencyGraph对象mDependencyGraph

3、ConstraintWidget：
①ConstraintLayout的每个child的LayoutParams中的数据，都会转换到对应的ConstraintWidget中，后续的测量是基于ConstraintWidget的。
②ConstraintWidgetContainer也继承了ConstraintWidgetContainer。
③通过getCompanionWidget()方法，可以获取到ConstraintWidget绑定的child。
④持有ConstraintAnchor列表，表示控件相互间的依赖关系。

4、BasicMeasure：测量流程的核心类。
①持有ArrayList<ConstraintWidget>类型变量mVariableDimensionsWidgets，mVariableDimensionsWidgets参与第二次绘制。

5、BasicMeasure#Measurer接口：
①所有的测量操作，最终都会交由BasicMeasure#Measurer#measure方法处理。
②唯一实现类是ConstraintLayout

6、BasicMeasure#Measure类：
①定义了measureStrategy的三种取值。
②定义了horizontalBehavior和verticalBehavior等数据

```

最终的测量逻辑，都在`ConstraintLayout#Measurer#measure(ConstraintWidget widget, BasicMeasure.Measure measure)`方法中。

