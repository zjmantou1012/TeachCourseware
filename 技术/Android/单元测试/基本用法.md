---
author: zjmantou
title: 基本用法
time: 2024-12-11 周三
tags:
  - Android
  - 单元测试
---
## 单元测试中的上下文获取

- InstrumentationRegistry.getInstrumentation().getTargetContext();
- ApplicationProvider.getApplicationContext()(AndroidX Test依赖);

## 查看测试覆盖率

- JaCoCo
- [Code Coverage](https://blog.csdn.net/huiling815/article/details/53312127) [相关操作](https://developer.android.com/codelabs/basic-android-kotlin-compose-test-viewmodel?hl=zh-cn#4)

# Activity

[测试Activity](https://developer.android.com/guide/components/activities/testing?hl=zh-cn) 

# Fragment

FragmentScenario：
- launchInContainer()
- launch()

测试内容：
1. UI测试
2. fragment跳转测试


# Paging

依赖库：paging-testing

## 界面层(Pagingdata)

### asSnapShot

- `Flow<PagingData<Value>>` 扩展 `asSnapShot`
- `List<Value>.asPagingSourceFactory()` : 测试数据的静态转换（如 `map()` 和 `insertSeparators()`）。

```kotlin
fun test_items_contain_one_to_ten() = runTest {
  // Get the Flow of PagingData from the ViewModel under test
  val items: Flow<PagingData<String>> = viewModel.items

  val itemsSnapshot: List<String> = items.asSnapshot {
    // Scroll to the 50th item in the list. This will also suspend till
    // the prefetch requirement is met if there's one.
    // It also suspends until all loading is complete.
    scrollTo(index = 50)
  }

  // With the asSnapshot complete, you can now verify that the snapshot
  // has the expected values
  assertEquals(
    expected = (0..50).map(Int::toString),
    actual = itemsSnapshot
  )
}
```

```kotlin

fun test_footer_is_visible() = runTest {
  // Get the Flow of PagingData from the ViewModel under test
  val items: Flow<PagingData<String>> = viewModel.items

  val itemsSnapshot: List<String> = items.asSnapshot {
    // Scroll till the footer is visible
    appendScrollWhile {  item: String -> item != "Footer" }
  }

```

### asPagingSourceFactory 

- `Flow<List<Value>>.asPagingSourceFactory()`: 测试数据更新（例如写入后备数据源）对分页流水线有何影响。

```kotlin
class MyViewModel(
  myRepository: myRepository
) {
  val items = Pager(
    config: PagingConfig,
    initialKey = null,
    pagingSourceFactory = { myRepository.pagingSource() }
  )
  .flow
  .map { pagingData ->
    pagingData.insertSeparators<String, String> { before, _ ->
      when {
        // Add a dashed String separator if the prior item is a multiple of 10
        before.last() == '0' -> "---------"
        // Return null to avoid adding a separator between two items.
        else -> null
      }
  }
}
```

## 数据层 (PagingSource) 

### TestPager 

```kotlin
class SubredditPagingSourceTest {
  private val mockPosts = listOf(
    postFactory.createRedditPost(DEFAULT_SUBREDDIT),
    postFactory.createRedditPost(DEFAULT_SUBREDDIT),
    postFactory.createRedditPost(DEFAULT_SUBREDDIT)
  )
  private val fakeApi = FakeRedditApi().apply {
    mockPosts.forEach { post -> addPost(post) }
  }

  @Test
  fun loadReturnsPageWhenOnSuccessfulLoadOfItemKeyedData() = runTest {
    val pagingSource = RedditPagingSource(
      fakeApi,
      DEFAULT_SUBREDDIT
    )

    val pager = TestPager(CONFIG, pagingSource)

    val result = pager.refresh() as LoadResult.Page

    // Write assertions against the loaded data
    assertThat(result.data)
    .containsExactlyElementsIn(mockPosts)
    .inOrder()
  }
}
```

测试连续加载情况：

```kotlin
    @Test
    fun test_consecutive_loads() = runTest {

      val page = with(pager) {
        refresh()
        append()
        append()
      } as LoadResult.Page

      assertThat(page.data)
      .containsExactlyElementsIn(testPosts)
      .inOrder()
    }
```

测试错误场景：
```kotlin
    @Test
    fun refresh_returnError() {
        val pagingSource = RedditPagingSource(
          fakeApi,
          DEFAULT_SUBREDDIT
        )
        // Configure your fake to return errors
        fakeApi.setReturnsError()
        val pager = TestPager(CONFIG, source)

        runTest {
            source.errorNextLoad = true
            val result = pager.refresh()
            assertTrue(result is LoadResult.Error)

            val page = pager.getLastLoadedPage()
            assertThat(page).isNull()
        }
    }
```

## RemoteMediator 

验证l`load()` 函数是否会返回正确的`MediatorResult` ， 更适合集成测试

## 端到端测试 

模拟API配置返回一组一组测试数据，是测试具有可重复性。

1. 初始化测试结构
2. 验证`Pager` 实现返回的数据正确性
3. 验证`Pager`对象是否会根据用户输入正确加载其他数据。

# Navigation 

依赖库：navigation-testing。 

结合FragmentScenario、Espresso 和 TestNavHostController。 

```kotlin
@RunWith(AndroidJUnit4::class)
class TitleScreenTest {

    @Test
    fun testNavigationToInGameScreen() {
        // Create a TestNavHostController
        val navController = TestNavHostController(
            ApplicationProvider.getApplicationContext())

        // Create a graphical FragmentScenario for the TitleScreen
        val titleScenario = launchFragmentInContainer<TitleScreen>()

        titleScenario.onFragment { fragment ->
            // Set the graph on the TestNavHostController
            navController.setGraph(R.navigation.trivia)

            // Make the NavController available via the findNavController() APIs
            Navigation.setViewNavController(fragment.requireView(), navController)
        }

        // Verify that performing a click changes the NavController’s state
        onView(ViewMatchers.withId(R.id.play_btn)).perform(ViewActions.click())
        assertThat(navController.currentDestination?.id).isEqualTo(R.id.in_game)
    }
}
```

## NavigationUI 

例如结合了Toolbar， 需要在生命周期早些时候设置TestNavHostController方法； 

例如，结合了Toolbar的fragment： 

```kotlin
class TitleScreen : Fragment(R.layout.fragment_title_screen) {
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val navController = view.findNavController()
        view.findViewById<Toolbar>(R.id.toolbar).setupWithNavController(navController)
    }
}
```

 我们需要在`onViewCreted()` 方法被调用之前创建NavController。 
 
 Fragment中可以使用`FragmentFactory`接口，注册生命周期回调。 
 
```kotlin
val scenario = launchFragmentInContainer {
    TitleScreen().also { fragment ->

        // In addition to returning a new instance of our Fragment,
        // get a callback whenever the fragment’s view is created
        // or destroyed so that we can set the NavController
        fragment.viewLifecycleOwnerLiveData.observeForever { viewLifecycleOwner ->
            if (viewLifecycleOwner != null) {
                // The fragment’s view has just been created
                navController.setGraph(R.navigation.trivia)
                Navigation.setViewNavController(fragment.requireView(), navController)
            }
        }
    }
}
```

# Kotlin-协程 

**CodeLab**：[Kotlin 05.3 中的高级 Android：测试协程和 Jetpack 集成](https://developer.android.com/codelabs/advanced-android-kotlin-training-testing-survey#0)

如何测试挂起函数。 

依赖库： org.jetbrains.kotlinx:kotlinx-coroutines-test 

runTest：封装协程。 

- 创建新协程，选择适当的`TestDispatcher`；
- 注入测试调度程序，替换代码中需要将协程移到其他调度程序中，比如`withContext`。 

## TestDispatchers 

### StandardTestDispatcher 

runTest默认使用此调度器，会在底层调度器上排队，以便在测试协程可供使用时运行。创建新协程，就需要“让出” 测试线程。 

```kotlin
@Test
fun standardTest() = runTest {
    val userRepo = UserRepository()

    launch { userRepo.register("Alice") }
    launch { userRepo.register("Bob") }

    assertEquals(listOf("Alice", "Bob"), userRepo.getAllUsers()) // ❌ Fails
}
```

可以使用：
- advanceUntilIdle：在调度器上运行所有其他协程，直到队列中没有任何内容。适合大多数场景。
- advanceTimeBy：将虚拟时间提前指定时长，并运行已调度为在该虚拟时间点之前运行的所有协程。
- runCurrent：运行已调度为在当前虚拟时间运行的协程。

```kotlin
@Test
fun standardTest() = runTest {
    val userRepo = UserRepository()

    launch { userRepo.register("Alice") }
    launch { userRepo.register("Bob") }
    advanceUntilIdle() // Yields to perform the registrations

    assertEquals(listOf("Alice", "Bob"), userRepo.getAllUsers()) // ✅ Passes
}
```

###  UnconfinedTestDispatcher 

如果新协程是在 `UnconfinedTestDispatcher` 上启动的，则这些协程会在当前线程上快速启动。即立即开始，而不会等到其协程构建器返回之后在运行。测试侧重并发不建议使用。 

```kotlin
@Test
fun unconfinedTest() = runTest(UnconfinedTestDispatcher()) {
    val userRepo = UserRepository()

    launch { userRepo.register("Alice") }
    launch { userRepo.register("Bob") }

    assertEquals(listOf("Alice", "Bob"), userRepo.getAllUsers()) // ✅ Passes
}
```

## 注入TestDispatcher 

## 设置MainDispatcher 

本地单元测试用无法使用MainDispatcher，例如LifecyclerScope或viewModelScope。 

- Dispatchers.setMain 
- Dispatchers.resetMain 

```kotlin
class HomeViewModelTest {
    @Test
    fun settingMainDispatcher() = runTest {
        val testDispatcher = UnconfinedTestDispatcher(testScheduler)
        Dispatchers.setMain(testDispatcher)

        try {
            val viewModel = HomeViewModel()
            viewModel.loadMessage() // Uses testDispatcher, runs its coroutine eagerly
            assertEquals("Greetings!", viewModel.message.value)
        } finally {
            Dispatchers.resetMain()
        }
    }
}
```

如果 Main 调度程序已替换为 TestDispatcher，任何新创建的 TestDispatchers 都将自动使用 Main 调度程序的调度器，包括由 runTest 创建的 StandardTestDispatcher（如果未向其中传入其他调度程序）。 

可以提取到TestRule中，避免每项测试重复创建。 

```kotlin
// Reusable JUnit4 TestRule to override the Main dispatcher
class MainDispatcherRule(
    val testDispatcher: TestDispatcher = UnconfinedTestDispatcher(),
) : TestWatcher() {
    override fun starting(description: Description) {
        Dispatchers.setMain(testDispatcher)
    }

    override fun finished(description: Description) {
        Dispatchers.resetMain()
    }
}

class HomeViewModelTestUsingRule {
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()

    @Test
    fun settingMainDispatcher() = runTest { // Uses Main’s scheduler
        val viewModel = HomeViewModel()
        viewModel.loadMessage()
        assertEquals("Greetings!", viewModel.message.value)
    }
}
```

也可以将UnconfinedTestDispatcher替换成StandardTestDispatcher传入。 

## 创建自己的TestScop 

```kotlin
class SimpleExampleTest {
    val testScope = TestScope() // Creates a StandardTestDispatcher

    @Test
    fun someTest() = testScope.runTest {
        // ...
    }
}
```


# Kotlin-Flow 

- 被测对象是接收方，那么在虚构依赖中生成数据流；
- 如果是发送方，读取并验证数据流发出的数据。 


## 测试发送方 

- `first()`： 取第一个值
- `toList()`: 多个值验证
- `single()`
- `count()` 
## 测试收集方 

创建收集协程，持续接收数据 

```kotlin
@Test
fun continuouslyCollect() = runTest {
    val dataSource = FakeDataSource()
    val repository = Repository(dataSource)

    val values = mutableListOf<Int>()
    backgroundScope.launch(UnconfinedTestDispatcher(testScheduler)) {
        repository.scores().toList(values)
    }

    dataSource.emit(1)
    assertEquals(10, values[0]) // Assert on the list contents

    dataSource.emit(2)
    dataSource.emit(3)
    assertEquals(30, values[2])

    assertEquals(3, values.size) // Assert the number of items collected
}

```

## 测试channel -> flow场景 

kotlin，有这样一个场景，一个类中有一个Channel,有个外部方法send(),通过这个方法，会发送一个事件到Channel中，有一个Flow流，是通过Channel.receiveAsFlow()收集Channel的事件并emit一个String，外部可以通过这个Flow 来收集数据，那么如何在单元测试中测试这样的flow呢？

实现思路是，使用 `collect` 函数来收集 `Flow` 发出的值，并使用断言来验证这些值。然后断言：
```kotlin
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Test

class MyClassTest {

    @Test
    fun testReceiveFlow() = runTest {
        val myClass = MyClass()
        val results = mutableListOf<String>()

        val job = launch {
            myClass.receiveFlow().toList(results)
        }

        myClass.send(1)
        myClass.send(2)
        myClass.send(3)
        advanceUntilIdle()

        job.cancel() // 停止收集 Flow，避免无限等待

        assertEquals(listOf("1", "2", "3"), results)
    }
}
```

### 使用三方库—— [Turbine](https://github.com/cashapp/turbine) 

创建收集协程的便捷API 

```kotlin
@Test
fun usingTurbine() = runTest {
    val dataSource = FakeDataSource()
    val repository = Repository(dataSource)

    repository.scores().test {
        // Make calls that will trigger value changes only within test{}
        dataSource.emit(1)
        assertEquals(10, awaitItem())

        dataSource.emit(2)
        awaitItem() // Ignore items if needed, can also use skip(n)

        dataSource.emit(3)
        assertEquals(30, awaitItem())
    }
}
```

## StateFlow 

可以像收集Flow一样观察值的变化，包括使用Turbine库。 

```kotlin
class FakeRepository : MyRepository {
    private val flow = MutableSharedFlow<Int>()
    suspend fun emit(value: Int) = flow.emit(value)
    override fun scores(): Flow<Int> = flow
}

@Test
fun testHotFakeRepository() = runTest {
    val fakeRepository = FakeRepository()
    val viewModel = MyViewModel(fakeRepository)

    assertEquals(0, viewModel.score.value) // Assert on the initial value

    // Start collecting values from the Repository
    viewModel.initialize()

    // Then we can send in values one by one, which the ViewModel will collect
    fakeRepository.emit(1)
    assertEquals(1, viewModel.score.value)

    fakeRepository.emit(2)
    fakeRepository.emit(3)
    assertEquals(3, viewModel.score.value) // Assert on the latest value
}
```

# RxJava

[参考链接](https://blog.csdn.net/mq2553299/article/details/78525488) 

[RxJavaPlugin使用方法](https://juejin.cn/post/6844903540507295758) 

	>注意，2.1.1版本中不知道什么原因，使用RxAndroidPlugins.setMainThreadSchedulerHandler方法时mainThread替换是不生效的，需要使用使用RxAndroidPlugins.setInitMainThreadSchedulerHandler



# ViewModel 

[[相关示例]]

[Advanced Android in Kotlin 05.1: Testing Basics](https://developer.android.com/codelabs/advanced-android-kotlin-training-testing-basics)

## 测试LiveData 

[示例链接](https://developer.android.com/codelabs/advanced-android-kotlin-training-testing-basics#8) 

```kotlin
@Test
fun addNewTask_setsNewTaskEvent() {

    // Given a fresh ViewModel
    val tasksViewModel = TasksViewModel(ApplicationProvider.getApplicationContext())


    // Create observer - no need for it to do anything!
    val observer = Observer<Event<Unit>> {}
    try {

        // Observe the LiveData forever
        tasksViewModel.newTaskEvent.observeForever(observer)

        // When adding a new task
        tasksViewModel.addNewTask()

        // Then the new task event is triggered
        val value = tasksViewModel.newTaskEvent.value
        assertThat(value?.getContentIfNotHandled(), (not(nullValue())))

    } finally {
        // Whatever happens, don't forget to remove the observer!
        tasksViewModel.newTaskEvent.removeObserver(observer)
    }
}
```


# Hilt 

## 依赖项 

```groovy
dependencies {
    // For Robolectric tests.
    testImplementation 'com.google.dagger:hilt-android-testing:2.51.1'
    // ...with Kotlin.
    kaptTest 'com.google.dagger:hilt-android-compiler:2.51.1'
    // ...with Java.
    testAnnotationProcessor 'com.google.dagger:hilt-android-compiler:2.51.1'


    // For instrumented tests.
    androidTestImplementation 'com.google.dagger:hilt-android-testing:2.51.1'
    // ...with Kotlin.
    kaptAndroidTest 'com.google.dagger:hilt-android-compiler:2.51.1'
    // ...with Java.
    androidTestAnnotationProcessor 'com.google.dagger:hilt-android-compiler:2.51.1'
}
```

## 单元测试 

```kotlin
@ActivityScoped
class AnalyticsAdapter @Inject constructor(
  private val service: AnalyticsService
) { ... }

class AnalyticsAdapterTest {

  @Test
  fun `Happy path`() {
    // You don't need Hilt to create an instance of AnalyticsAdapter.
    // You can pass a fake or mock AnalyticsService.
    val adapter = AnalyticsAdapter(fakeAnalyticsService)
    assertEquals(...)
  }
}
```

## 端到端 

### UI测试

```kotlin
@HiltAndroidTest
class SettingsActivityTest {

  @get:Rule
  var hiltRule = HiltAndroidRule(this)

  // UI tests here.
}
```

### TestApplication 

#### 插桩测试中自定义AndroidJUnitRunner 

```kotlin
// A custom runner to set up the instrumented application class for tests.
class CustomTestRunner : AndroidJUnitRunner() {

    override fun newApplication(cl: ClassLoader?, name: String?, context: Context?): Application {
        return super.newApplication(cl, HiltTestApplication::class.java.name, context)
    }
}
```

配置Gradle 

```groovy
android {
    defaultConfig {
        // Replace com.example.android.dagger with your class path.
        testInstrumentationRunner "com.example.android.dagger.CustomTestRunner"
    }
}
```

#### Robolectric测试中使用TestApplication 

可以在 robolectric.properties 文件中指定要使用的应用： 

`application = dagger.hilt.android.testing.HiltTestApplication` 

也可以使用`@Config` 注释在每个测试上单独配置 :

```kotlin
@HiltAndroidTest
@Config(application = HiltTestApplication::class)
class SettingsActivityTest {

  @get:Rule
  var hiltRule = HiltAndroidRule(this)

  // Robolectric tests here.
}
```

### 测试功能 

```kotlin
@HiltAndroidTest
class SettingsActivityTest {

  @get:Rule
  var hiltRule = HiltAndroidRule(this)

  @Inject
  lateinit var analyticsAdapter: AnalyticsAdapter

  @Before
  fun init() {
    hiltRule.inject()
  }

  @Test
  fun `happy path`() {
    // Can already use analyticsAdapter here.
  }
}
```

#### 替换绑定 

```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class AnalyticsModule {

  @Singleton
  @Binds
  abstract fun bindAnalyticsService(
    analyticsServiceImpl: AnalyticsServiceImpl
  ): AnalyticsService
}
```

在`test`或者`androidTest` 下使用虚假数据替换 

```kotlin
@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [AnalyticsModule::class]
)
abstract class FakeAnalyticsModule {

  @Singleton
  @Binds
  abstract fun bindAnalyticsService(
    fakeAnalyticsService: FakeAnalyticsService
  ): AnalyticsService
}
```

#### 替换单个测试中的绑定 

```kotlin
@UninstallModules(AnalyticsModule::class)
@HiltAndroidTest
class SettingsActivityTest {

  @Module
  @InstallIn(SingletonComponent::class)
  abstract class TestModule {

    @Singleton
    @Binds
    abstract fun bindAnalyticsService(
      fakeAnalyticsService: FakeAnalyticsService
    ): AnalyticsService
  }

  ...
}
```

#### 绑定新值 

`@BindValue` 

```kotlin
@UninstallModules(AnalyticsModule::class)
@HiltAndroidTest
class SettingsActivityTest {

  @BindValue @JvmField
  val analyticsService: AnalyticsService = FakeAnalyticsService()

  ...
}
```

## 其他情况 

### 自定义TestApplication

```kotlin

@CustomTestApplication(BaseApplication::class)
interface HiltTestApplication
```

### 多个TestRule对象 

```kotlin
@HiltAndroidTest
class SettingsActivityTest {

  @get:Rule
  var rule = RuleChain.outerRule(HiltAndroidRule(this)).
        around(SettingsActivityTestRule(...))

  // UI tests here.
}
```

或者 

```kotlin
@HiltAndroidTest
class SettingsActivityTest {

  @get:Rule(order = 0)
  var hiltRule = HiltAndroidRule(this)

  @get:Rule(order = 1)
  var settingsActivityTestRule = SettingsActivityTestRule(...)

  // UI tests here.
}
```

### launchFragmentInContainer 

[`launchFragmentInHiltContainer`](https://github.com/android/architecture-samples/blob/views-hilt/app/src/androidTest/java/com/example/android/architecture/blueprints/todoapp/HiltExt.kt#L37) 替换`launchFragmentInContainer` 

### 单例组件 

`@EarlyEntryPoint` 

参考[Hilt 文档](https://dagger.dev/hilt/early-entry-point)。

# 集成测试 

[10. 任务：使用 Espresso 编写您的第一个集成测试](https://developer.android.com/codelabs/advanced-android-kotlin-training-testing-test-doubles/#9)

[端到端&DataBinding](https://developer.android.com/codelabs/advanced-android-kotlin-training-testing-survey#7) 

[Hilt端到端测试](https://developer.android.com/training/dependency-injection/hilt-testing?hl=zh-cn#end-to-end) 

