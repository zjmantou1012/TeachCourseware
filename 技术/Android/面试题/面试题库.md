---
author: zjmantou
title: 面试题库
time: 2024-03-26 周二
tags:
  - Android
  - 面试
---
# 项目介绍

## 负责模块

## 介绍一下客户端的发布测试流程
调试
自测冒烟
提测（大版本看涉及范围要不要全量回归，小版本测相关改动需求及部分回归）
封板发布


# 专业技能

## 基础

### 介绍一下Activity生命周期中的7个方法

![](https://images0.cnblogs.com/blog/589447/201312/09150206-83936c5adfda4a10a5f01954ca1f4935.png)

Fragment生命周期：
1. [onAttach__](https://m.baidu.com/s?word=onAttach&sa=re_dqa_zy)：当Fragment与Activity关联时调用。
2. [onCreate__](https://m.baidu.com/s?word=onCreate&sa=re_dqa_zy)：初始化Fragment时调用。
3. [onCreateView__](https://m.baidu.com/s?word=onCreateView&sa=re_dqa_zy)：创建Fragment的视图时调用。
4. onActivityCreated：当Activity的onCreate方法完成后调用。
5. [onStart__](https://m.baidu.com/s?word=onStart&sa=re_dqa_zy)：Fragment在UI中可见时调用。
6. [onResume__](https://m.baidu.com/s?word=onResume&sa=re_dqa_zy)：Fragment的UI和用户交互时调用。
7. [onPause__](https://m.baidu.com/s?word=onPause&sa=re_dqa_zy)：当Activity转为onPause状态时调用。
8. [onStop__](https://m.baidu.com/s?word=onStop&sa=re_dqa_zy)：当有组件完全销毁或宿主Activity转为onStop时调用。
9. [onDestroyView__](https://m.baidu.com/s?word=onDestroyView&sa=re_dqa_zy)：Fragment清理View时调用，即移除Fragment视图。（**ViewBinding需要在这里去制null**）
10. onDestroy：Fragment完成对View的清理的时候调用。
11. onDetach：当Fragment从Activity删除的时候调用。

ViewBinding的封装：kotlin委托+生命周期监听

```kotlin
class LifecycleAwareViewBinding<F : Fragment, V : ViewBinding> : ReadWriteProperty<F, V>, LifecycleEventObserver {

    private var binding: V? = null

    override fun getValue(thisRef: F, property: KProperty<*>): V {
        binding?.let {
            return it
        }
        throw IllegalStateException("Can't access ViewBinding before onCreateView and after onDestroyView!")
    }

    override fun setValue(thisRef: F, property: KProperty<*>, value: V) {
        if (thisRef.viewLifecycleOwner.lifecycle.currentState == Lifecycle.State.DESTROYED) {
            throw IllegalStateException("Can't set ViewBinding after onDestroyView!")
        }
        thisRef.viewLifecycleOwner.lifecycle.addObserver(this)
        binding = value
    }

    override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) {
        if (event == Lifecycle.Event.ON_DESTROY) {
            binding = null
            source.lifecycle.removeObserver(this)
        }
    }
}

```

委托有哪些：
- 委托类
- 属性委托：//总结：委托一个类去完成赋值(set)与取值(get)的操作
- 委托取值：by lazy，实现getValue委托
	- SYNCHRONIZED：线程安全，通过synchronized来实现
	- PUBLICATION：线程安全，通过CAS（AtomicReferenceFieldUpdater）比较，可能存在多次初始化
	- NONE：线程不安全
- 委托参数：map
- 委托监测模式：委托监测变量变化
- 委托绑定属性：委托监测变量变化
![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202403271352891.png)



### 介绍一下MVVM设计模式


### JVM垃圾回收过程


### Java 多线程开发实现的几种方案
1. 继承Thread类、实现Runnable接口
2. 实现Callable接口通过FutureTask包装器来创建Thread线程
3. 使用ExecutorService、Callable
4. Future实现有返回结果的多线程
5. kotlin协程



### Hash Table和HashMap区别

hasTable继承Dictionary类，线程安全的，
hashmap线程不安全，继承的是Map接口。 

这个一定要去看源码！看源码！看源码！实在看不下去的可以上网看别人的分析。简单总结有几点：

1. HashMap 支持 null Key 和 null Value；Hashtable 不允许。这是因为 HashMap 对 null 进行了特殊处理，将 null 的 hashCode 值定为了 0，从而将其存放在哈希表的第 0 个 bucket。
2. HashMap 是非线程安全，HashMap 实现线程安全方法为 Map map = Collections.synchronziedMap(new HashMap())；HashTable 是线程安全
3. HashMap 默认长度是 16，扩容是原先的 2 倍；Hashtable 默认长度是 11，扩容是原先的 2n+1
4. HashMap 继承 AbstractMap；HashTable 继承了 Dictionary

扩展，HashMap 对比 ConcurrentHashMap ，HashMap 对比 SparseArray，LinkedArray 对比 ArrayList，ArrayList 对比 Vector

### 什么是线程死锁，如何有效的避免线程死锁？

两个或两个以上的线程持有不同系统资源的锁，线程彼此都等待获取对方的锁来完成自己的任务，但是没有让出自己持有的锁，线程就会无休止等待下去。线程竞争的资源可以是：锁、网络连接、通知事件，磁盘、带宽，以及一切可以被称作“资源”的东西。

可以借助工具：jconsole

如何避免：

死锁的四个必要条件：

1. 互斥条件：至少有一个资源被独占，被占用的资源不能同时被其他线程访问。
    
2. 请求与保持条件：一个线程在持有资源的同时，又请求其他线程所持有的资源。
    
3. 不可剥夺条件：已经分配给一个线程的资源不能被其他线程抢占，只能由持有者释放。
    
4. 循环等待条件：存在一种等待循环，其中每个线程都在等待下一个线程所持有的资源。

要避免死锁，可以采取以下方法：

1. 避免使用多个锁：尽量减少使用多个锁，或者将多个锁合并为一个锁，从而避免死锁的发生。
    
2. 统一获取锁的顺序：不同线程按照相同的顺序获取锁，避免因为锁的竞争顺序不一致而导致死锁。
    
3. 加锁时限制等待时间：在获取锁时设置一个超时时间，如果超过一定时间还未获取到锁，就放弃该锁的获取。
    
4. 死锁检测与恢复：通过系统监控和检测，发现死锁后采取相应的恢复措施，如中断某个线程，释放资源。
    
5. 资源有序分配：对资源进行合理的分配和管理，避免循环等待的产生。

## kotlin

### kotlin 实现单例的方式有哪些？

#### 一 饿汉模式

```kotlin
/**
 * 饿汉模式
 */
object SingleTest {
    fun show() {
        println("饿汉模式")
    }
}

```

饿汉模式优点：方便，快，一个object关键字就OK了，线程安全的
饿汉模式缺点：类加载慢，不能延时加载，浪费内存

#### 三 双重检测模式

```kotlin
/**
 * 懒汉模式
 */
class SingleTest1 {
    companion object {
        private val singleTest by lazy { SingleTest1() }
        fun getInstance() = singleTest
    }

    fun show() {
        println("懒汉模式")
    }
}

```
线程安全



### Kotlin中的可见性修饰符有哪些？相比于Java有什么区别？

private、 protected、 internal 和 public， 默认public

与Java区别
1、 Kotlin 抛弃了 Java 中的默认访问控制符default，添加了 internal 访问控制符；

2、 Kotlin 中的访问控制符的修饰范围扩大到 包级元素，包括包级属性和包级函数；

3、 Kotlin 对 private 和 protected 的访问范围进行了一些修改。

**1、Java**

|           |         |         |         |        |
| --------- | ------- | ------- | ------- | ------ |
| 类中成员修饰符   | 同一类中可访问 | 同一包中可访问 | 不同包中可访问 | 子类中可访问 |
| public    | √       | √       | √       | √      |
| protected | √       | √       | ×       | √      |
| (default) | √       | √       | ×       | ×      |
| private   | √       | ×       | ×       | ×      |
|           |         |         |         |        |


**2、Kotlin**

|           |          |          |          |
| --------- | -------- | -------- | -------- |
| 包中成员修饰符   | 同一文件中可访问 | 同一模块中可访问 | 不同模块中可访问 |
| public    | √        | √        | √        |
| internal  | √        | √        | ×        |
| protected | 不适用于顶层声明 |          |          |
| private   | √        | ×        | ×        |

### Kotlin中集合遍历有哪几种方式
1. for in
2. for ..
3. for until
4. for each
5. repeat
6. for downTo
7. find
8. map

### 谈谈Kotlin中的Sequence，为什么它处理集合操作更加高效？

操作符进行链式调用时，例如 map 和 filter 时，都会在函数内部创建中间集合，如果元素特别多就会造成性能问题；

为什么序列更高效？
1. 序列对集合的操作是惰性的。
    
2. 不需要额外的创建中间集合保存链式操作的中间结果。

如何理解惰性：
比如map.filter.find，会先对第一个元素进行map和filter然后find，满足就返回了


[Kotlin 性能优化利器 —— Sqeuence 原理浅析](https://blog.csdn.net/Android_2012_/article/details/90722980)

### 你觉得Kotlin与Java混合开发时需要注意哪些问题

1. 继承问题，尽量不要混合继承，kotlin无法处理default关键字
2. 互相调用问题，兼容性
3. 类型参数、空安全等

## 其他

### 衡量应用稳定性的指标有哪些？如何监控这些指标？


### 常见的安卓平台上得几种加固方式？

1. 混淆代码：混淆代码可以使代码的逻辑更难被破解者理解，从而增加攻击者的攻击难度。

　　2. 加密资源文件：通过使用加密算法来加密APK中的资源文件，使得攻击者更难以获取敏感信息。

　　3. 动态加载类和方法：动态加载类和方法可以使得攻击者更难以找到特定的代码段，从而增加攻击难度。

　　4. 检测和防御反编译：通过检测和防御反编译，可以防止攻击者获取APK的源代码，从而保护代码的安全性。

　　5. 防止二次打包：通过在APK中加入验证机制，可以防止攻击者对APK进行二次打包。

　　6. 加密网络通信：通过加密网络通信，可以防止攻击者对网络数据进行窃听和篡改，保护数据的安全性。

　　7. 使用数字签名：通过使用数字签名，可以验证APK的真实性，防止攻击者伪造APK，从而保护手机的安全性。

### 如何防止app二次打包？

- 混淆加固
- 数字签名
- 加固网络请求
- 服务端校验
- 使用加固工具



### 跨端方案原理理解
 
跨端通过渲染引擎实现多端统一的效果  

通过消息与native层通信调用方法；

### 常见的设计模式

## 规范


### 上个项目开发流程规范有哪些？如果通过非CR方式保障代码质量，措施有哪些？

Android studio lint工具，
QAPlug 插件，还可以帮忙找到bug
阿里巴巴开发规约差劲
借助公司代码扫描工具；

### 如果做开发项目权限划分？

# 软性素质

## 学习能力

### 最近学习的内容及应用情况

## 协作流程

### 上家公司开发流程介绍以及存在的问

