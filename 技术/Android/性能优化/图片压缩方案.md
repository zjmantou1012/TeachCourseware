---
author: zjmantou
title: 图片压缩方案
time: 2023-10-26 周四
tags:
  - Android
  - 技术
---
# 基础知识

## Bitmap概念

Bitmap对象本质是一张图片的内容在手机内存中的表达形式。它将图片的内容看做是由存储数据的有限个像素点组成；每个像素点存储该像素点位置的ARGB值。每个像素点的ARGB值确定下来，这张图片的内容就相应地确定下来了。
>Bitmap和BitmapFactory重要的函数可以参考[Android 图片缓存之 Bitmap 详解](https://juejin.cn/post/6844903442939412493#heading-5)

## 色彩模式

Bitmap.Config表示每个像素点对ARGB通道值的存储方案：

- ALPHA_8：每个像素占8位（1个字节），存储透明度信息，没有颜色信息。
- RGB_565：没有透明度，R=5，G=6，B=5，，那么一个像素点占5+6+5=16位（2字节），能表示2^16种颜色。
- ARGB_4444：由4个4位组成，即A=4，R=4，G=4，B=4，那么一个像素点占4+4+4+4=16位 （2字节），能表示2^12种颜色。
- ARGB_8888：由4个8位组成，即A=8，R=8，G=8，B=8，那么一个像素点占8+8+8+8=32位（4字节），能表示2^24种颜色。

## 色深与位深的概念

### 色深
即色彩的深度，指每一个像素是由多少bit来存储ARGB值，属于图片自身的一种属性。 

色深可以用来衡量一张图片的色彩处理能力。典型的色深有8-bit、16-bit、24-bit、32-bit。  

Bitmap.Config参数的数值指的就是色深，比如**ARGB_8888**方式的色深为**32**位，**RGB_565**方式的色深是**16**位。`色深是数字图像参数。`

### 位深度

在记录数字图像的颜色时，计算机实际上是用每个像素需要的二进制数值位数来表示的。当这些数据按照一定的编排方式被记录在计算机中，就构成了一个数字图像的二进制文件。[^每一个像素在计算机中所使用的这种位数就是“位深度”，位深是物理硬件参数，主要用来存储。]

举例某张图片100像素*100像素 色深32位(ARGB_8888)，保存时位深度为24位，那么：
- 该图片在内存中所占大小为：100 * 100 * (32 / 8) Byte
- 在文件中所占大小为 100 * 100 * ( 24/ 8 ) * 压缩率 Byte

>拓展知识：
>24位颜色可称之为真彩色，色深度是24，它能组合成2的24次幂种颜色，即：16777216种颜色，超过了人眼能够分辨的颜色数量。

### 总结

**色深和位深分别来计算图片在内存和文件中所占用的大小**

## 内存中Bitmap大小
![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202310261514974.png)

Android中，图片来源是res的不同资源目录时，图片被加载进内存时的分辨率会经过一层转换，虽然此时图片的大小计算公式仍然是 分辨率 x 每个像素点的大小，但此时的分辨率已经不是图片本身的分辨率了，详情可以参考[[字节跳动面试官：一张图片占据的内存大小是如何计算]]，规则如下：
`新分辨率 = 原图横向分辨率 * (设备的 dpi / 目录对应的 dpi ) * 原图纵向分辨率 * (设备的 dpi / 目录对应的 dpi ).  
- 当使用 `Glide` 时，如果有设置图片显示的控件，那么会自动按照控件的大小，降低图片的分辨率加载。图片来源是 `res` 的分辨率转换规则对它也无效。
- 当使用 `fresco` 时，不管图片来源是哪里，即使是 `res`，图片占用的内存大小仍旧以原图的分辨率计算。
- 其他图片的来源，如磁盘，文件，流等，均按照原图的分辨率来进行计算图片的内存大小。

#### BitmapFactory.decodeResource()源码计算占用内存：
```Java
BitmapFactory.java
    public static Bitmap decodeResourceStream(Resources res, TypedValue value,InputStream is, Rect pad, Options opts) {
        if (opts == null) {
            opts = new Options();
        }
        if (opts.inDensity == 0 && value != null) {
            final int density = value.density;
            if (density == TypedValue.DENSITY_DEFAULT) {
                //inDensity默认为图片所在文件夹对应的密度
                opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;
            } else if (density != TypedValue.DENSITY_NONE) {
                opts.inDensity = density;
            }
        }
        if (opts.inTargetDensity == 0 && res != null) {
            //inTargetDensity为当前系统密度。
            opts.inTargetDensity = res.getDisplayMetrics().densityDpi;
        }
        return decodeStream(is, pad, opts);
    }
    
    BitmapFactory.cpp 此处只列出主要代码。
    static jobject doDecode(JNIEnv* env, SkStreamRewindable* stream, jobject padding, jobject options) {
        //初始缩放系数
        float scale = 1.0f;
        if (env->GetBooleanField(options, gOptions_scaledFieldID)) {
            const int density = env->GetIntField(options, gOptions_densityFieldID);
            const int targetDensity = env->GetIntField(options, gOptions_targetDensityFieldID);
            const int screenDensity = env->GetIntField(options, gOptions_screenDensityFieldID);
            if (density != 0 && targetDensity != 0 && density != screenDensity) {
                //缩放系数是当前系数密度/图片所在文件夹对应的密度；
                scale = (float) targetDensity / density;
            }
        }
        //原始解码出来的Bitmap；
        SkBitmap decodingBitmap;
        if (decoder->decode(stream, &decodingBitmap, prefColorType, decodeMode)
                != SkImageDecoder::kSuccess) {
            return nullObjectReturn("decoder->decode returned false");
        }
        //原始解码出来的Bitmap的宽高；
        int scaledWidth = decodingBitmap.width();
        int scaledHeight = decodingBitmap.height();
        //要使用缩放系数进行缩放，缩放后的宽高；
        if (willScale && decodeMode != SkImageDecoder::kDecodeBounds_Mode) {
            scaledWidth = int(scaledWidth * scale + 0.5f);
            scaledHeight = int(scaledHeight * scale + 0.5f);
        }    
        //源码解释为因为历史原因；sx、sy基本等于scale。
        const float sx = scaledWidth / float(decodingBitmap.width());
        const float sy = scaledHeight / float(decodingBitmap.height());
        canvas.scale(sx, sy);
        canvas.drawARGB(0x00, 0x00, 0x00, 0x00);
        canvas.drawBitmap(decodingBitmap, 0.0f, 0.0f, &paint);
        // now create the java bitmap
        return GraphicsJNI::createBitmap(env, javaAllocator.getStorageObjAndReset(),
            bitmapCreateFlags, ninePatchChunk, ninePatchInsets, -1);
    }

```

`width * height * nTargetDensity/inDensity * nTargetDensity/inDensity * 一个像素所占的内存`

即新分辨率 * 一个像素所占用的内存

## 小结
- **位深和色深有什么区别，他们是一个东西吗？**
	- 位深和色深看着其实差不多，都用24-bit和32-bit等来表示，而且一个图片的色深和位深有可能是一样（例如都是24bit），但一个是图片的参数，一个是用于存储的物理硬件参数。
- **为什么Bitmap不能直接保存，Bitmap和PNG、JPG到底是什么关系？**
	- Bitmap是图片在内存中的表示形式，GIF、JPEG、BMP、PNG和WebP等格式图片是持久化存储后的图片， jpg、png 只是图片的容器。而当图片加载到内存中以显示的时候，应该将磁盘上压缩存储的图片内容完整地展开即为解压缩过程，所以bitmap很大，不能直接存储，在内存中很容易造成OOM。
- **图片占用的内存大小公式：图片分辨率 * 每个像素点大小，这种说法正确吗？**
	- 说法也对，但是不全对，没有说明场景，同时也忽略了一个影响项：Density，可以参考[解析Bitmap的density](https://www.jianshu.com/p/aed7b7f010dc)。公式应为： `width * height * nTargetDensity/inDensity * nTargetDensity/inDensity * 一个像素所占的内存`
- **为什么有时候同一个 app，app 内的同个界面上的同张图片，但在不同设备上所耗内存却不一样？**
	- 因为不同设备的分辨率不同，导致加载到内存中的大小也不一样.
- **同一张图片，在界面上显示的控件大小不同时，它的内存大小也会跟随着改变吗？**
	- 热门的开源图片库，内部基本都会有一些图片的优化处理操作，当使用 Glide 时，会自动按照控件的大小，降低图片的分辨率加载，它的内存大小也会随着改变。

# Android中图片压缩的方法介绍

主要有两种方式压缩：
- 质量压缩：
	- 在不改变图片尺寸的情况下，改变图片的存储体积。
- 采样压缩：
	- 是降低图像尺寸，达到相同目的。

## 质量压缩
```Java
ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
//quality 为0～100，0表示最小体积，100表示最高质量，对应体积也是最大
bitmap.compress(Bitmap.CompressFormat.JPEG, quality , outputStream);

```

![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202310261540904.png)

### 质量压缩逻辑
compress函数最后调用来到native层：
```cpp
//Bitmap.cpp
static jboolean Bitmap_compress(JNIEnv* env, jobject clazz, jlong bitmapHandle,
                                jint format, jint quality,
                                jobject jstream, jbyteArray jstorage) {

    LocalScopedBitmap bitmap(bitmapHandle);
    SkImageEncoder::Type fm;

    switch (format) {
    case kJPEG_JavaEncodeFormat:
        fm = SkImageEncoder::kJPEG_Type;
        break;
    case kPNG_JavaEncodeFormat:
        fm = SkImageEncoder::kPNG_Type;
        break;
    case kWEBP_JavaEncodeFormat:
        fm = SkImageEncoder::kWEBP_Type;
        break;
    default:
        return JNI_FALSE;
    }

    if (!bitmap.valid()) {
        return JNI_FALSE;
    }

    bool success = false;

    std::unique_ptr<SkWStream> strm(CreateJavaOutputStreamAdaptor(env, jstream, jstorage));
    if (!strm.get()) {
        return JNI_FALSE;
    }

    std::unique_ptr<SkImageEncoder> encoder(SkImageEncoder::Create(fm));
    if (encoder.get()) {
        SkBitmap skbitmap;
        bitmap->getSkBitmap(&skbitmap);
        success = encoder->encodeStream(strm.get(), skbitmap, quality);
    }
    return success ? JNI_TRUE : JNI_FALSE;
}

```

最后调用了函数 encoder->encodeStream(....) 编码保存本地。该函数是调用 `skia 引擎`来对图片进行编码压缩，对`skia` 的介绍将在后文讲解 [底层哈夫曼压缩](https://juejin.cn/post/7036719089804394532 "https://juejin.cn/post/7036719089804394532")时展开

## 尺寸压缩

### 邻近采样（Nearest Neighbour Resampling）
```Java
BitmapFactory.Options options = new BitmapFactory.Options();
//或者 inDensity 搭配 inTargetDensity 使用，算法和 inSampleSize 一样
options.inSampleSize = 2; //设置图片的缩放比例(宽和高) , google推荐用2的倍数：
Bitmap bitmap = BitmapFactory.decodeFile("xxx.png");
Bitmap compress = BitmapFactory.decodeFile("xxx.png", options);

```

设置inSampleSize的值(int类型)后，假如设为4，则宽和高都为原来的1/4，宽高都减少了，自然内存也降低了。

>邻近采样的方式比较粗暴，直接选择其中的一个像素作为生成像素，另一个像素直接抛弃，这样就造成了图片变成了纯绿色，也就是红色像素被抛弃。

**邻近采样**采用的算法叫做**邻近点插值算法**。

### 双线性采样（Bilinear Resampling）

```Java
Bitmap bitmap = BitmapFactory.decodeFile("xxx.png");
Bitmap compress = Bitmap.createScaledBitmap(bitmap, bitmap.getWidth()/2, bitmap.getHeight()/2, true);
或者直接使用 matrix 进行缩放

Bitmap bitmap = BitmapFactory.decodeFile("xxx.png");
Matrix matrix = new Matrix();
matrix.setScale(0.5f, 0.5f);
bm = Bitmap.createBitmap(bitmap, 0, 0, bit.getWidth(), bit.getHeight(), matrix, true);
```

**双线性采样**使用的是**双线性內插值算法**，这个算法不像**邻近点插值**算法一样，直接粗暴的选择一个像素，而是参考了源像素相应位置周围 2x2 个点的值，根据相对位置取对应的权重，经过计算之后得到目标图像。

 **双线性采样**对比**邻近采样**的优势在于：

- 它的系数可以是小数，而不一定是整数，在某些压缩限制下，效果尤为明显
- 处理文字比较多的图片在展示效果上的差别，双线性采样效果要更好

还有**双三次采样**和**Lanczos**采样等，具体分析可以参考 [Android 中图片压缩分析（下）](https://link.juejin.cn/?target=https%3A%2F%2Fcloud.tencent.com%2Fdeveloper%2Farticle%2F1006352 "https://cloud.tencent.com/developer/article/1006352")这篇QQ音乐大佬的分享。

## 小结

- 实际开发中往往是质量压缩和尺寸压缩搭配使用。
- 对于时间要求不高的，倾向使用双线性采样去压缩。
- 对于质量要求高的，可以采用双三次采样和Lanczos，但计算量都比较大，其中Lanczos最大。

# 实战——Luban压缩算法解析仿微信朋友圈

## 1、微信的算法解析

- 第一步进行采样率压缩；
- 第二步进行宽高的等比例压缩（微信对原图和缩略图限制了最大长宽或者最小长宽）；
- 第三步就是对图片的质量进行压缩（一般75或者70）；
- 第四部就是采用webP的格式。

## 2、Luban的算法解析

`Luban`压缩目前的步骤只占了微信算法中的第二与第三步，算法逻辑如下：

1. 判断图片比例值，是否处于哪个区间内；
2. 判断图片最长边是否过边界值；
3. 计算压缩图片实际边长值，以第2步计算结果为准，超过某个边界值则
	- width / pow(2, n-1)
	- height/ pow(2, n-1)
4. 计算压缩图片的实际文件大小，以第2、3步结果为准，图片比例越大则文件越大。
5. 判断第4步的size是否过小。
6. 将前面求到的值压缩图片 width, height, size 传入压缩流程，压缩图片直到满足以上数值。

## 源码
```Java
// 计算采样压缩的值，也就是模仿微信的经验值，核心内容
private int computeSize() {
// 补齐宽度和长度
    srcWidth = srcWidth % 2 == 1 ? srcWidth + 1 : srcWidth;
    srcHeight = srcHeight % 2 == 1 ? srcHeight + 1 : srcHeight;

// 获取长边和短边
    int longSide = Math.max(srcWidth, srcHeight);
    int shortSide = Math.min(srcWidth, srcHeight);

// 获取图片的比例系数，如果在区间[1, 0.5625) 中即图片处于 [1:1 ~ 9:16) 比例
    float scale = ((float) shortSide / longSide);
// 开始判断图片处于那种比例中，就是上面所说的第一个步骤
    if (scale <= 1 && scale > 0.5625) {
// 判断图片最长边是否过边界值，此边界值是模仿微信的一个经验值，就是上面所说的第二个步骤
      if (longSide < 1664) {
// 返回的是 options.inSampleSize的值，就是采样压缩的系数，是int型，Google建议是2的倍数
        return 1;
      } else if (longSide < 4990) {
        return 2;
// 这个10240上面的逻辑没有提到，也是经验值，不用去管它，你可以随意调整
      } else if (longSide > 4990 && longSide < 10240) {
        return 4;
      } else {
        return longSide / 1280 == 0 ? 1 : longSide / 1280;
      }
// 这些判断都是逆向推导的经验值，也可以说是一种策略
    } else if (scale <= 0.5625 && scale > 0.5) {
      return longSide / 1280 == 0 ? 1 : longSide / 1280;
    } else {
    // 此时图片的比例是一个长图，采用策略向上取整
      return (int) Math.ceil(longSide / (1280.0 / scale));
    }
  }
  
// 图片旋转方法
private Bitmap rotatingImage(Bitmap bitmap, int angle) {
    Matrix matrix = new Matrix();
// 将传入的bitmap 进行角度旋转
    matrix.postRotate(angle);
// 返回一个新的bitmap
    return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);
  }

// 压缩方法，返回一个File
File compress() throws IOException {
// 创建一个option对象
    BitmapFactory.Options options = new BitmapFactory.Options();
// 获取采样压缩的值
    options.inSampleSize = computeSize();
// 把图片进行采样压缩后放入一个bitmap， 参数1是bitmap图片的格式，前面获取的
    Bitmap tagBitmap = BitmapFactory.decodeStream(srcImg.open(), null, options);
// 创建一个输出流的对象
    ByteArrayOutputStream stream = new ByteArrayOutputStream();
// 判断是否是JPG图片
    if (Checker.SINGLE.isJPG(srcImg.open())) {
// Checker.SINGLE.getOrientation这个方法是检测图片是否被旋转过，对图片进行矫正
      tagBitmap = rotatingImage(tagBitmap, Checker.SINGLE.getOrientation(srcImg.open()));
    }
// 对图片进行质量压缩，参数1：通过是否有透明通道来判断是PNG格式还是JPG格式，
// 参数2：压缩质量固定为60，参数3：压缩完后将bitmap写入到字节流中
    tagBitmap.compress(focusAlpha ? Bitmap.CompressFormat.PNG : Bitmap.CompressFormat.JPEG, 60, stream);
// bitmap用完回收掉
    tagBitmap.recycle();
// 将图片流写入到File中，然后刷新缓冲区，关闭文件流和Byte流
    FileOutputStream fos = new FileOutputStream(tagImg);
    fos.write(stream.toByteArray());
    fos.flush();
    fos.close();
    stream.close();
    return tagImg;
  }


```



## 鲁班框架问题
- 解码前没有对内存做出预判
- 质量压缩写死 60
- 没有提供图片输出格式选择
- 不支持多文件合理并行压缩，输出顺序和压缩顺序不能保证一致
- 检测文件格式和图像的角度多次重复创建InputStream,增加不必要开销，增加OOM风险
- 可能出现内存泄漏，需要自己合理处理生命周期
- 图片要是有大小限制，只能进行重复压缩
- 原框架用的还是RxJava1.0

## 技术改造方案

- 解码前利用获取的图片宽高对内存占用做出计算，超出内存的使用RGB-565尝试解码
- 针对质量压缩的时候，提供传入质量系数的接口
- 对图片输出支持多种格式，不局限于File
- 利用协程来实现异步压缩和并行压缩任务，可以在合适时机取消协程来终止任务
- 参考Glide对字节数组的复用，以及InputStream的mark()、reset()来优化重复打开开销
- 利用LiveData来实现监听，自动注销监听。
- 压缩前计算好大小，逆向推导出尺寸压缩系数和质量压缩系数
- 现在已经出了RxJava3和协程，但大多数项目中已经有了线程池，要利用项目中的线程池，而不是导入一个三方库就建一个线程池而造成资源浪费

# 底层哈夫曼压缩讲解

## Skia图像引擎

![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202310261628364.png)

具体参考[可能是最详细的Android图片压缩原理分析（三）—— 底层哈夫曼压缩讲解](https://juejin.cn/post/7036719089804394532)

### 手写JPEG图像处理引擎

导入jpeglib.h及其他依赖头文件

![image.png](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202310261645214.png)

照着安卓源码中 libjpeg-turbo库里的example.c文件（系统提供的例子），开始编写native-lib.cpp文件：

```c++
#include <jni.h>
#include <string>
#include <android/bitmap.h>
#include <android/log.h>
#include <malloc.h>
// 因为头文件都是c文件，咱们写的是.cpp 是C++文件，这时候就需要混编，所以加入下面关键字
extern "C"
{
#include "jpeglib.h"
}
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,LOG_TAG,__VA_ARGS__)
#define LOG_TAG "louis"
#define true 1
typedef uint8_t BYTE;
// 写入图片函数
void writeImg(BYTE *data, const char *path, int w, int h) {

//  信使： java与C沟通的桥梁，jpeg的结构体，保存的比如宽、高、位深、图片格式等信息
    struct jpeg_compress_struct jpeg_struct;
//  设置错误处理信息 当读完整个文件的时候就会回调my_error_exit，例如内置卡出错、没权限等
    jpeg_error_mgr err;
    jpeg_struct.err = jpeg_std_error(&err);
//  给结构体分配内存
    jpeg_create_compress(&jpeg_struct);
//  打开输出文件
    FILE *file = fopen(path, "wb");
//  设置输出路径
    jpeg_stdio_dest(&jpeg_struct, file);

    jpeg_struct.image_width = w;
    jpeg_struct.image_height = h;
//  初始化  初始化
//  改成FALSE   ---》 开启hufuman算法
    jpeg_struct.arith_code = FALSE;
//  是否采用哈弗曼表数据计算 品质相差2倍多，官方实测， 吹5-10倍的都是扯淡
    jpeg_struct.optimize_coding = TRUE;
//  设置结构体的颜色空间为RGB
    jpeg_struct.in_color_space = JCS_RGB;
//  颜色通道数量
    jpeg_struct.input_components = 3;
//  其他的设置默认
    jpeg_set_defaults(&jpeg_struct);
//  设置质量
    jpeg_set_quality(&jpeg_struct, 60, true);
//  开始压缩，(是否写入全部像素)
    jpeg_start_compress(&jpeg_struct, TRUE);
    JSAMPROW row_pointer[1];
//    一行的rgb
    int row_stride = w * 3;
//  一行一行遍历 如果当前的行数小于图片的高度，就进入循环
    while (jpeg_struct.next_scanline < h) {
//      得到一行的首地址
        row_pointer[0] = &data[jpeg_struct.next_scanline * w * 3];
//		此方法会将jcs.next_scanline加1
        jpeg_write_scanlines(&jpeg_struct, row_pointer, 1);//row_pointer就是一行的首地址，1：写入的行数
    }
    jpeg_finish_compress(&jpeg_struct);
    jpeg_destroy_compress(&jpeg_struct);
    fclose(file);
}

extern "C"
JNIEXPORT void JNICALL
    Java_com_maniu_wechatimagesend_MainActivity_compress(JNIEnv *env, 
												    	 jobject instance,
												    	 jobject bitmap, 
												    	 jstring path_) {

    const char *path = env->GetStringUTFChars(path_, 0);
//  获取Bitmap信息
    AndroidBitmapInfo bitmapInfo;
    AndroidBitmap_getInfo(env, bitmap, &bitmapInfo);
//  存储ARGB所有像素点
    BYTE *pixels;
//  1、读取Bitmap所有像素信息
    AndroidBitmap_lockPixels(env, bitmap, (void **) &pixels);
//  获取bitmap的 宽，高，format
    int h = bitmapInfo.height;
    int w = bitmapInfo.width;
//  存储RGB所有像素点
    BYTE *data,*tmpData;
//  2、解析每个像素，去除A通量，取出RGB通量，
//  假如图片的像素是1920*1080，只有RGB三个颜色通道的话，计算公式为 w*h*3
    data= (BYTE *) malloc(w * h * 3);
//  存储RGB首地址
    tmpData = data;
    BYTE r, g, b;
    int color;
    for (int i = 0; i < h; ++i) {
        for (int j = 0; j < w; ++j) {
            color = *((int *) pixels);
            // 取出R G B 
            r = ((color & 0x00FF0000) >> 16);
            g = ((color & 0x0000FF00) >> 8);
            b = ((color & 0x000000FF));
            // 赋值
            *data = b;
            *(data + 1) = g;
            *(data + 2) = r;
            // 指针后移
            data += 3;
            pixels += 4;
        }
    }
//  3、读取像素点完毕 解锁，
    AndroidBitmap_unlockPixels(env, bitmap);
//  直接用data写数据
    writeImg(tmpData, path, w, h);
    env->ReleaseStringUTFChars(path_, path);
}

```


# 参考资料

[可能是最详细的Android图片压缩原理分析（一）—— Android图片压缩必备基础知识](https://juejin.cn/post/7036714008644157447)
[Android 图片缓存之 Bitmap 详解](https://juejin.cn/post/6844903442939412493#heading-5)
[解析Bitmap的density](https://www.jianshu.com/p/aed7b7f010dc)
[Android 中图片压缩分析（上）](https://cloud.tencent.com/developer/article/1006307) 
[Android中图片压缩分析（下）](https://cloud.tencent.c. m/developer/article/1006352)
[[Android中图片压缩分析（上）]]
[[Android中图片压缩分析（下）]]

[可能是最详细的Android图片压缩原理分析（二）—— 鲁班压缩算法解析](https://juejin.cn/post/7036716428174557221)
[可能是最详细的Android图片压缩原理分析（三）—— 底层哈夫曼压缩讲解](https://juejin.cn/post/7036719089804394532)
[哈夫曼树及编码讲解及例题](https://blog.csdn.net/weixin_41738030/article/details/89402695)
