---
author: zjmantou
title: 崩溃优化
time: 2023-10-22 周日
tags:
  - Android
  - 性能优化
---
# 崩溃原理

## Java Crash

1. 当线程由于未捕获的异常终止时，会调用Thread的UncaughtExceptionHandler的uncaughtException方法，如果未设置则会调用ThreadGroup进行处理
2. ThreadGroup的uncaughtException方法会查询线程设置的UncaughtExceptionHandler，如果没有的话，只是进行打印处理，并没有退出操作。说明一定有其他地方对Thread设置了UncaughtExceptionHandler。

### 什么时候设置的UncaughtExceptionHandler?

App启动时，在RuntimeInit.commonInit()方法中，会通过Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler)) 设置异常处理的handler。

```Java
protected static final void commonInit() {
    if (DEBUG) Slog.d(TAG, "Entered RuntimeInit!");
    /*
     * set handlers; these apply to all threads in the VM. Apps can replace
     * the default handler, but not the pre handler.
     */
    LoggingHandler loggingHandler = new LoggingHandler();
    RuntimeHooks.setUncaughtExceptionPreHandler(loggingHandler);
    Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler(loggingHandler));
    /*
     * Install a time zone supplier that uses the Android persistent time zone system property.
     */
    RuntimeHooks.setTimeZoneIdSupplier(() -> SystemProperties.get("persist.sys.timezone"));
    /*
     * Sets handler for java.util.logging to use Android log facilities.
     * The odd "new instance-and-then-throw-away" is a mirror of how
     * the "java.util.logging.config.class" system property works. We
     * can't use the system property here since the logger has almost
     * certainly already been initialized.
     */
    LogManager.getLogManager().reset();
    new AndroidConfig();
    /*
     * Sets the default HTTP User-Agent used by HttpURLConnection.
     */
    String userAgent = getDefaultUserAgent();
    System.setProperty("http.agent", userAgent);
    /*
     * Wire socket tagging to traffic stats.
     */
    NetworkManagementSocketTagger.install();
    initialized = true;
}
```

```java
private static class KillApplicationHandler implements Thread.UncaughtExceptionHandler {
    public void uncaughtException(Thread t, Throwable e) {
        try {
            ensureLogging(t, e);
            if (mCrashing) return;
            mCrashing = true;
            if (ActivityThread.currentActivityThread() != null) {
                ActivityThread.currentActivityThread().stopProfiling();
            }
            ActivityManager.getService().handleApplicationCrash(
                    mApplicationObject, new ApplicationErrorReport.ParcelableCrashInfo(e));
        } catch (Throwable t2) {
            ...
        } finally {
            // Try everything to make sure this process goes away.
            Process.killProcess(Process.myPid());
            System.exit(10);
        }
    }
}
```

### 总结
app启动时，设置了KillApplicationHandler，在uncaughtException方法中的finally中杀死了进程。

# Native Crash

### 处理流程
![native crash 处理流程](https://zjmantou-drawingbed.oss-cn-hangzhou.aliyuncs.com/picture/202310222202052.png)

## Java层监听

mActivityManagerService.startObservingNativeCrashes() 注册 native crash 的监听。开启一个soket监听。

## native上报

崩溃后会记录crash日志，然后通知AMS native crash。  

# 系统日志记录
可以记录 java crash、native crash、anr等，日志目录是：**/data/system/dropbox** 。


# 优化方案

1. 记录日志信息：记录手机信息、内存信息、Crash日志、屏幕截图等。
2. 让崩溃友好一些，自定义handler，重启app，减少直接退出的场景。
3. 使应用不崩溃。（Hook Activity Thread)


## CrashHandler

### 原理

系统出现未捕捉的异常后，会将异常一层层向上抛，我们知道主线程开启了looper循环，异常会导致循环退出，最终通过jvm调用到uncaughtException()方法。此时在主线程中通过Looper.loop()重启loop，即可继续处理App中的各种事件。

通过hook替换ActivityThread.mH.mCallback，对Activity的生命周期进行try catch，如果有异常的话，直接关闭准备显示的Activity。

```java
public class CrashHandler implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(@NonNull Thread thread, @NonNull Throwable ex) {
        handleExceptionReocrd(ex); // 自动记录日志
        try { // 交给用户记录日志
            if (listener != null) listener.recordException(ex);
        } catch (Throwable e) {
            e.printStackTrace();
        }

        try { // 是否重启APP，重启APP，需要杀掉进程
            if (listener != null && listener.restartApp()) return;
        } catch (Exception e) {
            Log.d(TAG, "uncaughtException->handleByUser：" + Log.getStackTraceString(e));
        }

        // 未重启，是否开启安全模式
        if (safeModelEnable) {
            enterSafeModel(thread);
        } else if (mDefaultHandler != null) {
            // 交给系统处理
            Log.d(TAG, "uncaughtException 交给系统处理");
            mDefaultHandler.uncaughtException(thread, ex);
        } else {
            // 没有系统的处理器，直接退出进程
            Log.w(TAG, "uncaughtException 退出进程");
            android.os.Process.killProcess(android.os.Process.myPid());
            System.exit(10);
        }
    }

    public void enterSafeModel(Thread thread) {
        Log.w(CrashHandler.TAG, "setSafe--- thread-----" + thread.getName());
        if (thread == Looper.getMainLooper().getThread()) {
            while (true) { //开启一个循环
                try {
                    Log.e(TAG, "safeMode: 检测到异常退出，开启looper");
                    Looper.loop();
                } catch (Throwable e) {
                    Log.e(TAG, "safeMode: 检测到异常退出：" + Log.getStackTraceString(e));
                }
            }
        }
    }
}
```


#### 参考资料

[Android崩溃原理和优化](https://www.jianshu.com/p/3c9399f1d1a2)

