# 导致内存泄漏的场景

## 静态内部类或单例

静态变量或单例不要持有activity或view等对象的引用，如果必须持有引用可以改为WeakReference。

## 内部类导致的内存泄漏

内部类生成class文件后会发现持有外部类的引用，如果是持久引用就容易发生泄漏
```Java
public class MainActivity$InnerClass {
    public MainActivity$InnerClass(MainActivity this$0) {
        this.this$0 = this$0;
    }
}

```

可以考虑是否可以使用静态内部类实现，静态内部类相当于普通类，不会持有外部类的引用。  

## 匿名内部类导致的内存泄漏

比如handler

```Java
public class MainActivity extends Activity {

    private Handler handler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            Log.d("TAG", msg.toString());
            super.handleMessage(msg);
        }
    };
}


class MainActivity$1 extends Handler {
    MainActivity$1(MainActivity this$0) {
        this.this$0 = this$0;
    }

    public void handleMessage(Message msg) {
        Log.d("TAG", msg.toString());
        super.handleMessage(msg);
    }
}

```

改成使用静态内部类

## 动画导致的内存泄漏

由动画源码分析可以知道：  
Animator在start()后会被一个单例类持有，在动画end或cancel后从callback列表中移除。  

如果Animator定义的匿名内部类listener又持有了activity，而动画是无限循行ValueAnimator.INFINITE，就导致动画start后如果不cancel，会发生内存泄漏。

解决办法：在activity销毁时，调用动画的cancel方法。

## 资源未关闭导致的内存泄露

资源性对象（例如InputStream/OutputStream，Cursor，File文件等）未及时close，也会导致gc无法回收这部分内存。

## Eventbus未取消注册导致内存泄漏

## 其他
注册了BroadcastReceiver、listener、RxJava subscription但是未取消注册等，也会造成内存泄漏。在开发中可能造成内存泄漏的bug很多，对于listener、receiver、observer、callback等对象，开发者应该仔细检查引用关系是否必要或合理，是否可能造成内存泄漏。


# 四种引用类型

1. 强引用(StrongReference)：在GC时，不会被回收；
2. 软引用(SoftReference)：内存不足时，如果一个对象只有软引用，才会被回收；
3. 弱引用(WeakReference)：在GC时，如果一个对象只有弱引用，则会被回收；
4. 虚引用(PhantomReference)：任何时候都有可能被回收；

# hprof获取方式

- Android Studio 的Profier工具；
- adb：`adb shell am dumpheap <processname> <filename>`;
- 代码获取：`Debug.dumpHprofData(fileName)`

